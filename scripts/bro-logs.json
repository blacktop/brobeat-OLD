{"logs": [{"description": "TCP/UDP/ICMP connections", "url": "https://www.bro.org/sphinx/scripts/base/protocols/conn/main.bro.html#type-Conn::Info", "fields": [{"field": "ts", "type": "time", "description": "This is the time of the first packet."}, {"field": "uid", "type": "string", "description": "A unique identifier of the connection."}, {"field": "id", "type": "conn_id", "description": "The connections 4-tuple of endpoint addresses/ports."}, {"field": "proto", "type": "transport_proto", "description": "The transport layer protocol of the connection."}, {"field": "service", "type": "string", "description": "An identification of an application protocol being sent over the connection."}, {"field": "duration", "type": "interval", "description": "How long the connection lasted.  For 3-way or 4-way connection tear-downs, this will not include the final ACK."}, {"field": "orig_bytes", "type": "count", "description": "The number of payload bytes the originator sent. For TCP this is taken from sequence numbers and might be inaccurate (e.g., due to large connections)."}, {"field": "resp_bytes", "type": "count", "description": "The number of payload bytes the responder sent. See orig_bytes."}, {"field": "conn_state", "type": "string", "description": ""}, {"field": "local_orig", "type": "bool", "description": "If the connection is originated locally, this value will be T. If it was originated remotely it will be F.  In the case that the Site::local_nets variable is undefined, this field will be left empty at all times."}, {"field": "local_resp", "type": "bool", "description": "If the connection is responded to locally, this value will be T. If it was responded to remotely it will be F.  In the case that the Site::local_nets variable is undefined, this field will be left empty at all times."}, {"field": "missed_bytes", "type": "count", "description": "Indicates the number of bytes missed in content gaps, which is representative of packet loss.  A value other than zero will normally cause protocol analysis to fail but some analysis may have been completed prior to the packet loss."}, {"field": "history", "type": "string", "description": "Records the state history of connections as a string of letters.  The meaning of those letters is:"}, {"field": "orig_pkts", "type": "count", "description": "Number of packets that the originator sent. Only set if use_conn_size_analyzer = T."}, {"field": "orig_ip_bytes", "type": "count", "description": "Number of IP level bytes that the originator sent (as seen on the wire, taken from the IP total_length header field). Only set if use_conn_size_analyzer = T."}, {"field": "resp_pkts", "type": "count", "description": "Number of packets that the responder sent. Only set if use_conn_size_analyzer = T."}, {"field": "resp_ip_bytes", "type": "count", "description": "Number of IP level bytes that the responder sent (as seen on the wire, taken from the IP total_length header field). Only set if use_conn_size_analyzer = T."}, {"field": "tunnel_parents", "type": "set", "description": "If this connection was over a tunnel, indicate the uid values for any encapsulating parent connections used over the lifetime of this inner connection."}, {"field": "orig_l2_addr", "type": "string", "description": "(present if policy/protocols/conn/mac-logging.bro is loaded)"}, {"field": "resp_l2_addr", "type": "string", "description": "(present if policy/protocols/conn/mac-logging.bro is loaded)"}, {"field": "vlan", "type": "int", "description": "(present if policy/protocols/conn/vlan-logging.bro is loaded)"}, {"field": "inner_vlan", "type": "int", "description": "(present if policy/protocols/conn/vlan-logging.bro is loaded)"}], "file": "conn.log", "pattern": {"pattern": "%{NUMBER:ts}\\t%{NOTSPACE:uid}\\t%{IP:orig_h}\\t%{INT:orig_p}\\t%{IP:resp_h}\\t%{INT:resp_p}\\t%{WORD:proto}\\t%{GREEDYDATA:service}\\t%{GREEDYDATA:duration}\\t%{INT:orig_bytes}\\t%{INT:resp_bytes}\\t%{GREEDYDATA:conn_state}\\t%{GREEDYDATA:local_orig}\\t%{GREEDYDATA:local_resp}\\t%{INT:missed_bytes}\\t%{GREEDYDATA:history}\\t%{INT:orig_pkts}\\t%{INT:orig_ip_bytes}\\t%{INT:resp_pkts}\\t%{INT:resp_ip_bytes}\\t%{GREEDYDATA:tunnel_parents}\\t%{GREEDYDATA:orig_l2_addr}\\t%{GREEDYDATA:resp_l2_addr}\\t%{INT:vlan}\\t%{INT:inner_vlan}", "name": "BRO_CONN"}, "log_type": "conn"}, {"description": "Distributed Computing Environment/RPC", "url": "https://www.bro.org/sphinx/scripts/base/protocols/dce-rpc/main.bro.html#type-DCE_RPC::Info", "fields": [{"field": "ts", "type": "time", "description": "Timestamp for when the event happened."}, {"field": "uid", "type": "string", "description": "Unique ID for the connection."}, {"field": "id", "type": "conn_id", "description": "The connections 4-tuple of endpoint addresses/ports."}, {"field": "rtt", "type": "interval", "description": "Round trip time from the request to the response. If either the request or response wasnt seen, this will be null."}, {"field": "named_pipe", "type": "string", "description": "Remote pipe name."}, {"field": "endpoint", "type": "string", "description": "Endpoint name looked up from the uuid."}, {"field": "operation", "type": "string", "description": "Operation seen in the call."}], "file": "dce_rpc.log", "pattern": {"pattern": "%{NUMBER:ts}\\t%{NOTSPACE:uid}\\t%{IP:orig_h}\\t%{INT:orig_p}\\t%{IP:resp_h}\\t%{INT:resp_p}\\t%{GREEDYDATA:rtt}\\t%{GREEDYDATA:named_pipe}\\t%{GREEDYDATA:endpoint}\\t%{GREEDYDATA:operation}", "name": "BRO_DCE_RPC"}, "log_type": "dce_rpc"}, {"description": "DHCP leases", "url": "https://www.bro.org/sphinx/scripts/base/protocols/dhcp/main.bro.html#type-DHCP::Info", "fields": [{"field": "ts", "type": "time", "description": "The earliest time at which a DHCP message over the associated connection is observed."}, {"field": "uid", "type": "string", "description": "A unique identifier of the connection over which DHCP is occurring."}, {"field": "id", "type": "conn_id", "description": "The connections 4-tuple of endpoint addresses/ports."}, {"field": "mac", "type": "string", "description": "Clients hardware address."}, {"field": "assigned_ip", "type": "addr", "description": "Clients actual assigned IP address."}, {"field": "lease_time", "type": "interval", "description": "IP address lease interval."}, {"field": "trans_id", "type": "count", "description": "A random number chosen by the client for this transaction."}], "file": "dhcp.log", "pattern": {"pattern": "%{NUMBER:ts}\\t%{NOTSPACE:uid}\\t%{IP:orig_h}\\t%{INT:orig_p}\\t%{IP:resp_h}\\t%{INT:resp_p}\\t%{GREEDYDATA:mac}\\t%{IP:assigned_ip}\\t%{GREEDYDATA:lease_time}\\t%{INT:trans_id}", "name": "BRO_DHCP"}, "log_type": "dhcp"}, {"description": "DNP3 requests and replies", "url": "https://www.bro.org/sphinx/scripts/base/protocols/dnp3/main.bro.html#type-DNP3::Info", "fields": [{"field": "ts", "type": "time", "description": "Time of the request."}, {"field": "uid", "type": "string", "description": "Unique identifier for the connection."}, {"field": "id", "type": "conn_id", "description": "Identifier for the connection."}, {"field": "fc_request", "type": "string", "description": "The name of the function message in the request."}, {"field": "fc_reply", "type": "string", "description": "The name of the function message in the reply."}, {"field": "iin", "type": "count", "description": "The responses internal indication number."}], "file": "dnp3.log", "pattern": {"pattern": "%{NUMBER:ts}\\t%{NOTSPACE:uid}\\t%{IP:orig_h}\\t%{INT:orig_p}\\t%{IP:resp_h}\\t%{INT:resp_p}\\t%{GREEDYDATA:fc_request}\\t%{GREEDYDATA:fc_reply}\\t%{INT:iin}", "name": "BRO_DNP3"}, "log_type": "dnp3"}, {"description": "DNS activity", "url": "https://www.bro.org/sphinx/scripts/base/protocols/dns/main.bro.html#type-DNS::Info", "fields": [{"field": "ts", "type": "time", "description": "The earliest time at which a DNS protocol message over the associated connection is observed."}, {"field": "uid", "type": "string", "description": "A unique identifier of the connection over which DNS messages are being transferred."}, {"field": "id", "type": "conn_id", "description": "The connections 4-tuple of endpoint addresses/ports."}, {"field": "proto", "type": "transport_proto", "description": "The transport layer protocol of the connection."}, {"field": "trans_id", "type": "count", "description": "A 16-bit identifier assigned by the program that generated the DNS query.  Also used in responses to match up replies to outstanding queries."}, {"field": "rtt", "type": "interval", "description": "Round trip time for the query and response. This indicates the delay between when the request was seen until the answer started."}, {"field": "query", "type": "string", "description": "The domain name that is the subject of the DNS query."}, {"field": "qclass", "type": "count", "description": "The QCLASS value specifying the class of the query."}, {"field": "qclass_name", "type": "string", "description": "A descriptive name for the class of the query."}, {"field": "qtype", "type": "count", "description": "A QTYPE value specifying the type of the query."}, {"field": "qtype_name", "type": "string", "description": "A descriptive name for the type of the query."}, {"field": "rcode", "type": "count", "description": "The response code value in DNS response messages."}, {"field": "rcode_name", "type": "string", "description": "A descriptive name for the response code value."}, {"field": "AA", "type": "bool", "description": "The Authoritative Answer bit for response messages specifies that the responding name server is an authority for the domain name in the question section."}, {"field": "TC", "type": "bool", "description": "The Truncation bit specifies that the message was truncated."}, {"field": "RD", "type": "bool", "description": "The Recursion Desired bit in a request message indicates that the client wants recursive service for this query."}, {"field": "RA", "type": "bool", "description": "The Recursion Available bit in a response message indicates that the name server supports recursive queries."}, {"field": "Z", "type": "count", "description": "A reserved field that is usually zero in queries and responses."}, {"field": "answers", "type": "vector", "description": "The set of resource descriptions in the query answer."}, {"field": "TTLs", "type": "vector", "description": "The caching intervals of the associated RRs described by the answers field."}, {"field": "rejected", "type": "bool", "description": "The DNS query was rejected by the server."}, {"field": "total_answers", "type": "count", "description": "The total number of resource records in a reply messages answer section."}, {"field": "total_replies", "type": "count", "description": "The total number of resource records in a reply messages answer, authority, and additional sections."}, {"field": "saw_query", "type": "bool", "description": "Whether the full DNS query has been seen."}, {"field": "saw_reply", "type": "bool", "description": "Whether the full DNS reply has been seen."}, {"field": "auth", "type": "set", "description": "(present if policy/protocols/dns/auth-addl.bro is loaded)"}, {"field": "addl", "type": "set", "description": "(present if policy/protocols/dns/auth-addl.bro is loaded)"}], "file": "dns.log", "pattern": {"pattern": "%{NUMBER:ts}\\t%{NOTSPACE:uid}\\t%{IP:orig_h}\\t%{INT:orig_p}\\t%{IP:resp_h}\\t%{INT:resp_p}\\t%{WORD:proto}\\t%{INT:trans_id}\\t%{GREEDYDATA:rtt}\\t%{GREEDYDATA:query}\\t%{INT:qclass}\\t%{GREEDYDATA:qclass_name}\\t%{INT:qtype}\\t%{GREEDYDATA:qtype_name}\\t%{INT:rcode}\\t%{GREEDYDATA:rcode_name}\\t%{GREEDYDATA:AA}\\t%{GREEDYDATA:TC}\\t%{GREEDYDATA:RD}\\t%{GREEDYDATA:RA}\\t%{INT:Z}\\t%{GREEDYDATA:answers}\\t%{GREEDYDATA:TTLs}\\t%{GREEDYDATA:rejected}\\t%{INT:total_answers}\\t%{INT:total_replies}\\t%{GREEDYDATA:saw_query}\\t%{GREEDYDATA:saw_reply}\\t%{GREEDYDATA:auth}\\t%{GREEDYDATA:addl}", "name": "BRO_DNS"}, "log_type": "dns"}, {"description": "FTP activity", "url": "https://www.bro.org/sphinx/scripts/base/protocols/ftp/info.bro.html#type-FTP::Info", "fields": [{"field": "ts", "type": "time", "description": "Time when the command was sent."}, {"field": "uid", "type": "string", "description": "Unique ID for the connection."}, {"field": "id", "type": "conn_id", "description": "The connections 4-tuple of endpoint addresses/ports."}, {"field": "user", "type": "string", "description": "User name for the current FTP session."}, {"field": "password", "type": "string", "description": "Password for the current FTP session if captured."}, {"field": "command", "type": "string", "description": "Command given by the client."}, {"field": "arg", "type": "string", "description": "Argument for the command if one is given."}, {"field": "mime_type", "type": "string", "description": "Libmagic sniffed file type if the command indicates a file transfer."}, {"field": "file_size", "type": "count", "description": "Size of the file if the command indicates a file transfer."}, {"field": "reply_code", "type": "count", "description": "Reply code from the server in response to the command."}, {"field": "reply_msg", "type": "string", "description": "Reply message from the server in response to the command."}, {"field": "data_channel.passive", "type": "bool", "description": "Whether PASV mode is toggled for control channel."}, {"field": "data_channel.orig_h", "type": "addr", "description": "The host that will be initiating the data connection."}, {"field": "data_channel.resp_h", "type": "addr", "description": "The host that will be accepting the data connection."}, {"field": "data_channel.resp_p", "type": "port", "description": "The port at which the acceptor is listening for the data connection."}, {"field": "cwd", "type": "string", "description": "Current working directory that this session is in.  By making the default value ., we can indicate that unless something more concrete is discovered that the existing but unknown directory is ok to use."}, {"field": "cmdarg.ts", "type": "time", "description": "Time when the command was sent."}, {"field": "cmdarg.cmd", "type": "string", "description": "Command."}, {"field": "cmdarg.arg", "type": "string", "description": "Argument for the command if one was given."}, {"field": "cmdarg.seq", "type": "count", "description": "Counter to track how many commands have been executed."}, {"field": "pending_commands", "type": "FTP::PendingCmds", "description": ""}, {"field": "passive", "type": "bool", "description": "Indicates if the session is in active or passive mode."}, {"field": "capture_password", "type": "bool", "description": "Determines if the password will be captured for this request."}, {"field": "fuid", "type": "string", "description": "(present if base/protocols/ftp/files.bro is loaded)"}, {"field": "last_auth_requested", "type": "string", "description": "(present if base/protocols/ftp/gridftp.bro is loaded)"}], "file": "ftp.log", "pattern": {"pattern": "%{NUMBER:ts}\\t%{NOTSPACE:uid}\\t%{IP:orig_h}\\t%{INT:orig_p}\\t%{IP:resp_h}\\t%{INT:resp_p}\\t%{GREEDYDATA:user}\\t%{GREEDYDATA:password}\\t%{GREEDYDATA:command}\\t%{GREEDYDATA:arg}\\t%{GREEDYDATA:mime_type}\\t%{INT:file_size}\\t%{INT:reply_code}\\t%{GREEDYDATA:reply_msg}\\t%{GREEDYDATA:data_channel.passive}\\t%{IP:data_channel.orig_h}\\t%{IP:data_channel.resp_h}\\t%{INT:data_channel.resp_p}\\t%{GREEDYDATA:cwd}\\t%{NUMBER:cmdarg.ts}\\t%{GREEDYDATA:cmdarg.cmd}\\t%{GREEDYDATA:cmdarg.arg}\\t%{INT:cmdarg.seq}\\t%{GREEDYDATA:pending_commands}\\t%{GREEDYDATA:passive}\\t%{GREEDYDATA:capture_password}\\t%{NOTSPACE:fuid}\\t%{GREEDYDATA:last_auth_requested}", "name": "BRO_FTP"}, "log_type": "ftp"}, {"description": "HTTP requests and replies", "url": "https://www.bro.org/sphinx/scripts/base/protocols/http/main.bro.html#type-HTTP::Info", "fields": [{"field": "ts", "type": "time", "description": "Timestamp for when the request happened."}, {"field": "uid", "type": "string", "description": "Unique ID for the connection."}, {"field": "id", "type": "conn_id", "description": "The connections 4-tuple of endpoint addresses/ports."}, {"field": "trans_depth", "type": "count", "description": "Represents the pipelined depth into the connection of this request/response transaction."}, {"field": "method", "type": "string", "description": "Verb used in the HTTP request (GET, POST, HEAD, etc.)."}, {"field": "host", "type": "string", "description": "Value of the HOST header."}, {"field": "uri", "type": "string", "description": "URI used in the request."}, {"field": "referrer", "type": "string", "description": "Value of the referer header.  The comment is deliberately misspelled like the standard declares, but the name used here is referrer spelled correctly."}, {"field": "version", "type": "string", "description": "Value of the version portion of the request."}, {"field": "user_agent", "type": "string", "description": "Value of the User-Agent header from the client."}, {"field": "request_body_len", "type": "count", "description": "Actual uncompressed content size of the data transferred from the client."}, {"field": "response_body_len", "type": "count", "description": "Actual uncompressed content size of the data transferred from the server."}, {"field": "status_code", "type": "count", "description": "Status code returned by the server."}, {"field": "status_msg", "type": "string", "description": "Status message returned by the server."}, {"field": "info_code", "type": "count", "description": "Last seen 1xx informational reply code returned by the server."}, {"field": "info_msg", "type": "string", "description": "Last seen 1xx informational reply message returned by the server."}, {"field": "tags", "type": "set", "description": "A set of indicators of various attributes discovered and related to a particular request/response pair."}, {"field": "username", "type": "string", "description": "Username if basic-auth is performed for the request."}, {"field": "password", "type": "string", "description": "Password if basic-auth is performed for the request."}, {"field": "capture_password", "type": "bool", "description": "Determines if the password will be captured for this request."}, {"field": "proxied", "type": "set", "description": "All of the headers that may indicate if the request was proxied."}, {"field": "range_request", "type": "bool", "description": "Indicates if this request can assume 206 partial content in response."}, {"field": "orig_fuids", "type": "vector", "description": "(present if base/protocols/http/entities.bro is loaded)"}, {"field": "orig_filenames", "type": "vector", "description": "(present if base/protocols/http/entities.bro is loaded)"}, {"field": "orig_mime_types", "type": "vector", "description": "(present if base/protocols/http/entities.bro is loaded)"}, {"field": "resp_fuids", "type": "vector", "description": "(present if base/protocols/http/entities.bro is loaded)"}, {"field": "resp_filenames", "type": "vector", "description": "(present if base/protocols/http/entities.bro is loaded)"}, {"field": "resp_mime_types", "type": "vector", "description": "(present if base/protocols/http/entities.bro is loaded)"}, {"field": "current_entity.filename", "type": "string", "description": "Filename for the entity if discovered from a header."}, {"field": "orig_mime_depth", "type": "count", "description": "(present if base/protocols/http/entities.bro is loaded)"}, {"field": "resp_mime_depth", "type": "count", "description": "(present if base/protocols/http/entities.bro is loaded)"}, {"field": "client_header_names", "type": "vector", "description": "(present if policy/protocols/http/header-names.bro is loaded)"}, {"field": "server_header_names", "type": "vector", "description": "(present if policy/protocols/http/header-names.bro is loaded)"}, {"field": "omniture", "type": "bool", "description": "(present if policy/protocols/http/software-browser-plugins.bro is loaded)"}, {"field": "flash_version", "type": "string", "description": "(present if policy/protocols/http/software-browser-plugins.bro is loaded)"}, {"field": "cookie_vars", "type": "vector", "description": "(present if policy/protocols/http/var-extraction-cookies.bro is loaded)"}, {"field": "uri_vars", "type": "vector", "description": "(present if policy/protocols/http/var-extraction-uri.bro is loaded)"}], "file": "http.log", "pattern": {"pattern": "%{NUMBER:ts}\\t%{NOTSPACE:uid}\\t%{IP:orig_h}\\t%{INT:orig_p}\\t%{IP:resp_h}\\t%{INT:resp_p}\\t%{INT:trans_depth}\\t%{GREEDYDATA:method}\\t%{GREEDYDATA:host}\\t%{GREEDYDATA:uri}\\t%{GREEDYDATA:referrer}\\t%{GREEDYDATA:version}\\t%{GREEDYDATA:user_agent}\\t%{INT:request_body_len}\\t%{INT:response_body_len}\\t%{INT:status_code}\\t%{GREEDYDATA:status_msg}\\t%{INT:info_code}\\t%{GREEDYDATA:info_msg}\\t%{GREEDYDATA:tags}\\t%{GREEDYDATA:username}\\t%{GREEDYDATA:password}\\t%{GREEDYDATA:capture_password}\\t%{GREEDYDATA:proxied}\\t%{GREEDYDATA:range_request}\\t%{NOTSPACE:orig_fuids}\\t%{GREEDYDATA:orig_filenames}\\t%{GREEDYDATA:orig_mime_types}\\t%{NOTSPACE:resp_fuids}\\t%{GREEDYDATA:resp_filenames}\\t%{GREEDYDATA:resp_mime_types}\\t%{GREEDYDATA:current_entity.filename}\\t%{INT:orig_mime_depth}\\t%{INT:resp_mime_depth}\\t%{GREEDYDATA:client_header_names}\\t%{GREEDYDATA:server_header_names}\\t%{GREEDYDATA:omniture}\\t%{GREEDYDATA:flash_version}\\t%{GREEDYDATA:cookie_vars}\\t%{GREEDYDATA:uri_vars}", "name": "BRO_HTTP"}, "log_type": "http"}, {"description": "IRC commands and responses", "url": "https://www.bro.org/sphinx/scripts/base/protocols/irc/main.bro.html#type-IRC::Info", "fields": [{"field": "ts", "type": "time", "description": "Timestamp when the command was seen."}, {"field": "uid", "type": "string", "description": "Unique ID for the connection."}, {"field": "id", "type": "conn_id", "description": "The connections 4-tuple of endpoint addresses/ports."}, {"field": "nick", "type": "string", "description": "Nickname given for the connection."}, {"field": "user", "type": "string", "description": "Username given for the connection."}, {"field": "command", "type": "string", "description": "Command given by the client."}, {"field": "value", "type": "string", "description": "Value for the command given by the client."}, {"field": "addl", "type": "string", "description": "Any additional data for the command."}, {"field": "dcc_file_name", "type": "string", "description": "(present if base/protocols/irc/dcc-send.bro is loaded)"}, {"field": "dcc_file_size", "type": "count", "description": "(present if base/protocols/irc/dcc-send.bro is loaded)"}, {"field": "dcc_mime_type", "type": "string", "description": "(present if base/protocols/irc/dcc-send.bro is loaded)"}, {"field": "fuid", "type": "string", "description": "(present if base/protocols/irc/files.bro is loaded)"}], "file": "irc.log", "pattern": {"pattern": "%{NUMBER:ts}\\t%{NOTSPACE:uid}\\t%{IP:orig_h}\\t%{INT:orig_p}\\t%{IP:resp_h}\\t%{INT:resp_p}\\t%{GREEDYDATA:nick}\\t%{GREEDYDATA:user}\\t%{GREEDYDATA:command}\\t%{GREEDYDATA:value}\\t%{GREEDYDATA:addl}\\t%{GREEDYDATA:dcc_file_name}\\t%{INT:dcc_file_size}\\t%{GREEDYDATA:dcc_mime_type}\\t%{NOTSPACE:fuid}", "name": "BRO_IRC"}, "log_type": "irc"}, {"description": "Kerberos", "url": "https://www.bro.org/sphinx/scripts/base/protocols/krb/main.bro.html#type-KRB::Info", "fields": [{"field": "ts", "type": "time", "description": "Timestamp for when the event happened."}, {"field": "uid", "type": "string", "description": "Unique ID for the connection."}, {"field": "id", "type": "conn_id", "description": "The connections 4-tuple of endpoint addresses/ports."}, {"field": "request_type", "type": "string", "description": "Request type - Authentication Service (AS) or Ticket Granting Service (TGS)"}, {"field": "client", "type": "string", "description": "Client"}, {"field": "service", "type": "string", "description": "Service"}, {"field": "success", "type": "bool", "description": "Request result"}, {"field": "error_code", "type": "count", "description": "Error code"}, {"field": "error_msg", "type": "string", "description": "Error message"}, {"field": "from", "type": "time", "description": "Ticket valid from"}, {"field": "till", "type": "time", "description": "Ticket valid till"}, {"field": "cipher", "type": "string", "description": "Ticket encryption type"}, {"field": "forwardable", "type": "bool", "description": "Forwardable ticket requested"}, {"field": "renewable", "type": "bool", "description": "Renewable ticket requested"}, {"field": "logged", "type": "bool", "description": "Weve already logged this"}, {"field": "client_cert.ts", "type": "time", "description": "The time when the file was first seen."}, {"field": "client_cert.fuid", "type": "string", "description": "An identifier associated with a single file."}, {"field": "client_cert.tx_hosts", "type": "set", "description": "If this file was transferred over a network connection this should show the host or hosts that the data sourced from."}, {"field": "client_cert.rx_hosts", "type": "set", "description": "If this file was transferred over a network connection this should show the host or hosts that the data traveled to."}, {"field": "client_cert.conn_uids", "type": "set", "description": "Connection UIDs over which the file was transferred."}, {"field": "client_cert.source", "type": "string", "description": "An identification of the source of the file data.  E.g. it may be a network protocol over which it was transferred, or a local file path which was read, or some other input source."}, {"field": "client_cert.depth", "type": "count", "description": "A value to represent the depth of this file in relation to its source.  In SMTP, it is the depth of the MIME attachment on the message.  In HTTP, it is the depth of the request within the TCP connection."}, {"field": "client_cert.analyzers", "type": "set", "description": "A set of analysis types done during the file analysis."}, {"field": "client_cert.mime_type", "type": "string", "description": "A mime type provided by the strongest file magic signature match against the bof_buffer field of fa_file, or in the cases where no buffering of the beginning of file occurs, an initial guess of the mime type based on the first data seen."}, {"field": "client_cert.filename", "type": "string", "description": "A filename for the file if one is available from the source for the file.  These will frequently come from Content-Disposition headers in network protocols."}, {"field": "client_cert.duration", "type": "interval", "description": "The duration the file was analyzed for."}, {"field": "client_cert.local_orig", "type": "bool", "description": "If the source of this file is a network connection, this field indicates if the data originated from the local network or not as determined by the configured Site::local_nets."}, {"field": "client_cert.is_orig", "type": "bool", "description": "If the source of this file is a network connection, this field indicates if the file is being sent by the originator of the connection or the responder."}, {"field": "client_cert.seen_bytes", "type": "count", "description": "Number of bytes provided to the file analysis engine for the file."}, {"field": "client_cert.total_bytes", "type": "count", "description": "Total number of bytes that are supposed to comprise the full file."}, {"field": "client_cert.missing_bytes", "type": "count", "description": "The number of bytes in the file stream that were completely missed during the process of analysis e.g. due to dropped packets."}, {"field": "client_cert.overflow_bytes", "type": "count", "description": "The number of bytes in the file stream that were not delivered to stream file analyzers.  This could be overlapping bytes or bytes that couldnt be reassembled."}, {"field": "client_cert.timedout", "type": "bool", "description": "Whether the file analysis timed out at least once for the file."}, {"field": "client_cert.parent_fuid", "type": "string", "description": "Identifier associated with a container file from which this one was extracted as part of the file analysis."}, {"field": "client_cert.md5", "type": "string", "description": "(present if base/files/hash/main.bro is loaded)"}, {"field": "client_cert.sha1", "type": "string", "description": "(present if base/files/hash/main.bro is loaded)"}, {"field": "client_cert.sha256", "type": "string", "description": "(present if base/files/hash/main.bro is loaded)"}, {"field": "client_cert.x509", "type": "X509::Info", "description": "(present if base/files/x509/main.bro is loaded)"}, {"field": "client_cert.extracted", "type": "string", "description": "(present if base/files/extract/main.bro is loaded)"}, {"field": "client_cert.entropy", "type": "double", "description": "(present if policy/frameworks/files/entropy-test-all-files.bro is loaded)"}, {"field": "client_cert_subject", "type": "string", "description": "(present if base/protocols/krb/files.bro is loaded)"}, {"field": "client_cert_fuid", "type": "string", "description": "(present if base/protocols/krb/files.bro is loaded)"}, {"field": "server_cert.ts", "type": "time", "description": "The time when the file was first seen."}, {"field": "server_cert.fuid", "type": "string", "description": "An identifier associated with a single file."}, {"field": "server_cert.tx_hosts", "type": "set", "description": "If this file was transferred over a network connection this should show the host or hosts that the data sourced from."}, {"field": "server_cert.rx_hosts", "type": "set", "description": "If this file was transferred over a network connection this should show the host or hosts that the data traveled to."}, {"field": "server_cert.conn_uids", "type": "set", "description": "Connection UIDs over which the file was transferred."}, {"field": "server_cert.source", "type": "string", "description": "An identification of the source of the file data.  E.g. it may be a network protocol over which it was transferred, or a local file path which was read, or some other input source."}, {"field": "server_cert.depth", "type": "count", "description": "A value to represent the depth of this file in relation to its source.  In SMTP, it is the depth of the MIME attachment on the message.  In HTTP, it is the depth of the request within the TCP connection."}, {"field": "server_cert.analyzers", "type": "set", "description": "A set of analysis types done during the file analysis."}, {"field": "server_cert.mime_type", "type": "string", "description": "A mime type provided by the strongest file magic signature match against the bof_buffer field of fa_file, or in the cases where no buffering of the beginning of file occurs, an initial guess of the mime type based on the first data seen."}, {"field": "server_cert.filename", "type": "string", "description": "A filename for the file if one is available from the source for the file.  These will frequently come from Content-Disposition headers in network protocols."}, {"field": "server_cert.duration", "type": "interval", "description": "The duration the file was analyzed for."}, {"field": "server_cert.local_orig", "type": "bool", "description": "If the source of this file is a network connection, this field indicates if the data originated from the local network or not as determined by the configured Site::local_nets."}, {"field": "server_cert.is_orig", "type": "bool", "description": "If the source of this file is a network connection, this field indicates if the file is being sent by the originator of the connection or the responder."}, {"field": "server_cert.seen_bytes", "type": "count", "description": "Number of bytes provided to the file analysis engine for the file."}, {"field": "server_cert.total_bytes", "type": "count", "description": "Total number of bytes that are supposed to comprise the full file."}, {"field": "server_cert.missing_bytes", "type": "count", "description": "The number of bytes in the file stream that were completely missed during the process of analysis e.g. due to dropped packets."}, {"field": "server_cert.overflow_bytes", "type": "count", "description": "The number of bytes in the file stream that were not delivered to stream file analyzers.  This could be overlapping bytes or bytes that couldnt be reassembled."}, {"field": "server_cert.timedout", "type": "bool", "description": "Whether the file analysis timed out at least once for the file."}, {"field": "server_cert.parent_fuid", "type": "string", "description": "Identifier associated with a container file from which this one was extracted as part of the file analysis."}, {"field": "server_cert.md5", "type": "string", "description": "(present if base/files/hash/main.bro is loaded)"}, {"field": "server_cert.sha1", "type": "string", "description": "(present if base/files/hash/main.bro is loaded)"}, {"field": "server_cert.sha256", "type": "string", "description": "(present if base/files/hash/main.bro is loaded)"}, {"field": "server_cert.x509", "type": "X509::Info", "description": "(present if base/files/x509/main.bro is loaded)"}, {"field": "server_cert.extracted", "type": "string", "description": "(present if base/files/extract/main.bro is loaded)"}, {"field": "server_cert.entropy", "type": "double", "description": "(present if policy/frameworks/files/entropy-test-all-files.bro is loaded)"}, {"field": "server_cert_subject", "type": "string", "description": "(present if base/protocols/krb/files.bro is loaded)"}, {"field": "server_cert_fuid", "type": "string", "description": "(present if base/protocols/krb/files.bro is loaded)"}], "file": "kerberos.log", "pattern": {"pattern": "%{NUMBER:ts}\\t%{NOTSPACE:uid}\\t%{IP:orig_h}\\t%{INT:orig_p}\\t%{IP:resp_h}\\t%{INT:resp_p}\\t%{GREEDYDATA:request_type}\\t%{GREEDYDATA:client}\\t%{GREEDYDATA:service}\\t%{GREEDYDATA:success}\\t%{INT:error_code}\\t%{GREEDYDATA:error_msg}\\t%{NUMBER:from}\\t%{NUMBER:till}\\t%{GREEDYDATA:cipher}\\t%{GREEDYDATA:forwardable}\\t%{GREEDYDATA:renewable}\\t%{GREEDYDATA:logged}\\t%{NUMBER:client_cert.ts}\\t%{NOTSPACE:client_cert.fuid}\\t%{GREEDYDATA:client_cert.tx_hosts}\\t%{GREEDYDATA:client_cert.rx_hosts}\\t%{NOTSPACE:client_cert.conn_uids}\\t%{GREEDYDATA:client_cert.source}\\t%{INT:client_cert.depth}\\t%{GREEDYDATA:client_cert.analyzers}\\t%{GREEDYDATA:client_cert.mime_type}\\t%{GREEDYDATA:client_cert.filename}\\t%{GREEDYDATA:client_cert.duration}\\t%{GREEDYDATA:client_cert.local_orig}\\t%{GREEDYDATA:client_cert.is_orig}\\t%{INT:client_cert.seen_bytes}\\t%{INT:client_cert.total_bytes}\\t%{INT:client_cert.missing_bytes}\\t%{INT:client_cert.overflow_bytes}\\t%{GREEDYDATA:client_cert.timedout}\\t%{NOTSPACE:client_cert.parent_fuid}\\t%{GREEDYDATA:client_cert.md5}\\t%{GREEDYDATA:client_cert.sha1}\\t%{GREEDYDATA:client_cert.sha256}\\t%{GREEDYDATA:client_cert.x509}\\t%{GREEDYDATA:client_cert.extracted}\\t%{GREEDYDATA:client_cert.entropy}\\t%{GREEDYDATA:client_cert_subject}\\t%{NOTSPACE:client_cert_fuid}\\t%{NUMBER:server_cert.ts}\\t%{NOTSPACE:server_cert.fuid}\\t%{GREEDYDATA:server_cert.tx_hosts}\\t%{GREEDYDATA:server_cert.rx_hosts}\\t%{NOTSPACE:server_cert.conn_uids}\\t%{GREEDYDATA:server_cert.source}\\t%{INT:server_cert.depth}\\t%{GREEDYDATA:server_cert.analyzers}\\t%{GREEDYDATA:server_cert.mime_type}\\t%{GREEDYDATA:server_cert.filename}\\t%{GREEDYDATA:server_cert.duration}\\t%{GREEDYDATA:server_cert.local_orig}\\t%{GREEDYDATA:server_cert.is_orig}\\t%{INT:server_cert.seen_bytes}\\t%{INT:server_cert.total_bytes}\\t%{INT:server_cert.missing_bytes}\\t%{INT:server_cert.overflow_bytes}\\t%{GREEDYDATA:server_cert.timedout}\\t%{NOTSPACE:server_cert.parent_fuid}\\t%{GREEDYDATA:server_cert.md5}\\t%{GREEDYDATA:server_cert.sha1}\\t%{GREEDYDATA:server_cert.sha256}\\t%{GREEDYDATA:server_cert.x509}\\t%{GREEDYDATA:server_cert.extracted}\\t%{GREEDYDATA:server_cert.entropy}\\t%{GREEDYDATA:server_cert_subject}\\t%{NOTSPACE:server_cert_fuid}", "name": "BRO_KERBEROS"}, "log_type": "kerberos"}, {"description": "Modbus commands and responses", "url": "https://www.bro.org/sphinx/scripts/base/protocols/modbus/main.bro.html#type-Modbus::Info", "fields": [{"field": "ts", "type": "time", "description": "Time of the request."}, {"field": "uid", "type": "string", "description": "Unique identifier for the connection."}, {"field": "id", "type": "conn_id", "description": "Identifier for the connection."}, {"field": "func", "type": "string", "description": "The name of the function message that was sent."}, {"field": "exception", "type": "string", "description": "The exception if the response was a failure."}, {"field": "track_address", "type": "count", "description": "(present if policy/protocols/modbus/track-memmap.bro is loaded)"}], "file": "modbus.log", "pattern": {"pattern": "%{NUMBER:ts}\\t%{NOTSPACE:uid}\\t%{IP:orig_h}\\t%{INT:orig_p}\\t%{IP:resp_h}\\t%{INT:resp_p}\\t%{GREEDYDATA:func}\\t%{GREEDYDATA:exception}\\t%{INT:track_address}", "name": "BRO_MODBUS"}, "log_type": "modbus"}, {"description": "Tracks changes to Modbus holding\nregisters", "url": "https://www.bro.org/sphinx/scripts/policy/protocols/modbus/track-memmap.bro.html#type-Modbus::MemmapInfo", "fields": [{"field": "ts", "type": "time", "description": "Timestamp for the detected register change."}, {"field": "uid", "type": "string", "description": "Unique ID for the connection."}, {"field": "id", "type": "conn_id", "description": "Connection ID."}, {"field": "register", "type": "count", "description": "The device memory offset."}, {"field": "old_val", "type": "count", "description": "The old value stored in the register."}, {"field": "new_val", "type": "count", "description": "The new value stored in the register."}, {"field": "delta", "type": "interval", "description": "The time delta between when the old_val and new_val were seen."}], "file": "modbus_register_change.log", "pattern": {"pattern": "%{NUMBER:ts}\\t%{NOTSPACE:uid}\\t%{IP:orig_h}\\t%{INT:orig_p}\\t%{IP:resp_h}\\t%{INT:resp_p}\\t%{INT:register}\\t%{INT:old_val}\\t%{INT:new_val}\\t%{GREEDYDATA:delta}", "name": "BRO_MODBUS_REGISTER_CHANGE"}, "log_type": "modbus_register_change"}, {"description": "MySQL", "url": "https://www.bro.org/sphinx/scripts/base/protocols/mysql/main.bro.html#type-MySQL::Info", "fields": [{"field": "ts", "type": "time", "description": "Timestamp for when the event happened."}, {"field": "uid", "type": "string", "description": "Unique ID for the connection."}, {"field": "id", "type": "conn_id", "description": "The connections 4-tuple of endpoint addresses/ports."}, {"field": "cmd", "type": "string", "description": "The command that was issued"}, {"field": "arg", "type": "string", "description": "The argument issued to the command"}, {"field": "success", "type": "bool", "description": "Did the server tell us that the command succeeded?"}, {"field": "rows", "type": "count", "description": "The number of affected rows, if any"}, {"field": "response", "type": "string", "description": "Server message, if any"}], "file": "mysql.log", "pattern": {"pattern": "%{NUMBER:ts}\\t%{NOTSPACE:uid}\\t%{IP:orig_h}\\t%{INT:orig_p}\\t%{IP:resp_h}\\t%{INT:resp_p}\\t%{GREEDYDATA:cmd}\\t%{GREEDYDATA:arg}\\t%{GREEDYDATA:success}\\t%{INT:rows}\\t%{GREEDYDATA:response}", "name": "BRO_MYSQL"}, "log_type": "mysql"}, {"description": "NT LAN Manager (NTLM)", "url": "https://www.bro.org/sphinx/scripts/base/protocols/ntlm/main.bro.html#type-NTLM::Info", "fields": [{"field": "ts", "type": "time", "description": "Timestamp for when the event happened."}, {"field": "uid", "type": "string", "description": "Unique ID for the connection."}, {"field": "id", "type": "conn_id", "description": "The connections 4-tuple of endpoint addresses/ports."}, {"field": "username", "type": "string", "description": "Username given by the client."}, {"field": "hostname", "type": "string", "description": "Hostname given by the client."}, {"field": "domainname", "type": "string", "description": "Domainname given by the client."}, {"field": "success", "type": "bool", "description": "Indicate whether or not the authentication was successful."}, {"field": "status", "type": "string", "description": "A string representation of the status code that was returned in response to the authentication attempt."}, {"field": "done", "type": "bool", "description": "Internally used field to indicate if the login attempt has already been logged."}], "file": "ntlm.log", "pattern": {"pattern": "%{NUMBER:ts}\\t%{NOTSPACE:uid}\\t%{IP:orig_h}\\t%{INT:orig_p}\\t%{IP:resp_h}\\t%{INT:resp_p}\\t%{GREEDYDATA:username}\\t%{GREEDYDATA:hostname}\\t%{GREEDYDATA:domainname}\\t%{GREEDYDATA:success}\\t%{GREEDYDATA:status}\\t%{GREEDYDATA:done}", "name": "BRO_NTLM"}, "log_type": "ntlm"}, {"description": "RADIUS authentication attempts", "url": "https://www.bro.org/sphinx/scripts/base/protocols/radius/main.bro.html#type-RADIUS::Info", "fields": [{"field": "ts", "type": "time", "description": "Timestamp for when the event happened."}, {"field": "uid", "type": "string", "description": "Unique ID for the connection."}, {"field": "id", "type": "conn_id", "description": "The connections 4-tuple of endpoint addresses/ports."}, {"field": "username", "type": "string", "description": "The username, if present."}, {"field": "mac", "type": "string", "description": "MAC address, if present."}, {"field": "remote_ip", "type": "addr", "description": "Remote IP address, if present."}, {"field": "connect_info", "type": "string", "description": "Connect info, if present."}, {"field": "result", "type": "string", "description": "Successful or failed authentication."}, {"field": "logged", "type": "bool", "description": "Whether this has already been logged and can be ignored."}], "file": "radius.log", "pattern": {"pattern": "%{NUMBER:ts}\\t%{NOTSPACE:uid}\\t%{IP:orig_h}\\t%{INT:orig_p}\\t%{IP:resp_h}\\t%{INT:resp_p}\\t%{GREEDYDATA:username}\\t%{GREEDYDATA:mac}\\t%{IP:remote_ip}\\t%{GREEDYDATA:connect_info}\\t%{GREEDYDATA:result}\\t%{GREEDYDATA:logged}", "name": "BRO_RADIUS"}, "log_type": "radius"}, {"description": "RDP", "url": "https://www.bro.org/sphinx/scripts/base/protocols/rdp/main.bro.html#type-RDP::Info", "fields": [{"field": "ts", "type": "time", "description": "Timestamp for when the event happened."}, {"field": "uid", "type": "string", "description": "Unique ID for the connection."}, {"field": "id", "type": "conn_id", "description": "The connections 4-tuple of endpoint addresses/ports."}, {"field": "cookie", "type": "string", "description": "Cookie value used by the client machine. This is typically a username."}, {"field": "result", "type": "string", "description": "Status result for the connection.  Its a mix between RDP negotation failure messages and GCC server create response messages."}, {"field": "security_protocol", "type": "string", "description": "Security protocol chosen by the server."}, {"field": "keyboard_layout", "type": "string", "description": "Keyboard layout (language) of the client machine."}, {"field": "client_build", "type": "string", "description": "RDP client version used by the client machine."}, {"field": "client_name", "type": "string", "description": "Name of the client machine."}, {"field": "client_dig_product_id", "type": "string", "description": "Product ID of the client machine."}, {"field": "desktop_width", "type": "count", "description": "Desktop width of the client machine."}, {"field": "desktop_height", "type": "count", "description": "Desktop height of the client machine."}, {"field": "requested_color_depth", "type": "string", "description": "The color depth requested by the client in the high_color_depth field."}, {"field": "cert_type", "type": "string", "description": "If the connection is being encrypted with native RDP encryption, this is the type of cert being used."}, {"field": "cert_count", "type": "count", "description": "The number of certs seen.  X.509 can transfer an entire certificate chain."}, {"field": "cert_permanent", "type": "bool", "description": "Indicates if the provided certificate or certificate chain is permanent or temporary."}, {"field": "encryption_level", "type": "string", "description": "Encryption level of the connection."}, {"field": "encryption_method", "type": "string", "description": "Encryption method of the connection."}, {"field": "analyzer_id", "type": "count", "description": "The analyzer ID used for the analyzer instance attached to each connection.  It is not used for logging since its a meaningless arbitrary number."}, {"field": "done", "type": "bool", "description": "Track status of logging RDP connections."}, {"field": "ssl", "type": "bool", "description": "(present if policy/protocols/rdp/indicate_ssl.bro is loaded)"}], "file": "rdp.log", "pattern": {"pattern": "%{NUMBER:ts}\\t%{NOTSPACE:uid}\\t%{IP:orig_h}\\t%{INT:orig_p}\\t%{IP:resp_h}\\t%{INT:resp_p}\\t%{GREEDYDATA:cookie}\\t%{GREEDYDATA:result}\\t%{GREEDYDATA:security_protocol}\\t%{GREEDYDATA:keyboard_layout}\\t%{GREEDYDATA:client_build}\\t%{GREEDYDATA:client_name}\\t%{GREEDYDATA:client_dig_product_id}\\t%{INT:desktop_width}\\t%{INT:desktop_height}\\t%{GREEDYDATA:requested_color_depth}\\t%{GREEDYDATA:cert_type}\\t%{INT:cert_count}\\t%{GREEDYDATA:cert_permanent}\\t%{GREEDYDATA:encryption_level}\\t%{GREEDYDATA:encryption_method}\\t%{INT:analyzer_id}\\t%{GREEDYDATA:done}\\t%{GREEDYDATA:ssl}", "name": "BRO_RDP"}, "log_type": "rdp"}, {"description": "Remote Framebuffer (RFB)", "url": "https://www.bro.org/sphinx/scripts/base/protocols/rfb/main.bro.html#type-RFB::Info", "fields": [{"field": "ts", "type": "time", "description": "Timestamp for when the event happened."}, {"field": "uid", "type": "string", "description": "Unique ID for the connection."}, {"field": "id", "type": "conn_id", "description": "The connections 4-tuple of endpoint addresses/ports."}, {"field": "client_major_version", "type": "string", "description": "Major version of the client."}, {"field": "client_minor_version", "type": "string", "description": "Minor version of the client."}, {"field": "server_major_version", "type": "string", "description": "Major version of the server."}, {"field": "server_minor_version", "type": "string", "description": "Minor version of the server."}, {"field": "authentication_method", "type": "string", "description": "Identifier of authentication method used."}, {"field": "auth", "type": "bool", "description": "Whether or not authentication was successful."}, {"field": "share_flag", "type": "bool", "description": "Whether the client has an exclusive or a shared session."}, {"field": "desktop_name", "type": "string", "description": "Name of the screen that is being shared."}, {"field": "width", "type": "count", "description": "Width of the screen that is being shared."}, {"field": "height", "type": "count", "description": "Height of the screen that is being shared."}, {"field": "done", "type": "bool", "description": "Internally used value to determine if this connection has already been logged."}], "file": "rfb.log", "pattern": {"pattern": "%{NUMBER:ts}\\t%{NOTSPACE:uid}\\t%{IP:orig_h}\\t%{INT:orig_p}\\t%{IP:resp_h}\\t%{INT:resp_p}\\t%{GREEDYDATA:client_major_version}\\t%{GREEDYDATA:client_minor_version}\\t%{GREEDYDATA:server_major_version}\\t%{GREEDYDATA:server_minor_version}\\t%{GREEDYDATA:authentication_method}\\t%{GREEDYDATA:auth}\\t%{GREEDYDATA:share_flag}\\t%{GREEDYDATA:desktop_name}\\t%{INT:width}\\t%{INT:height}\\t%{GREEDYDATA:done}", "name": "BRO_RFB"}, "log_type": "rfb"}, {"description": "SIP", "url": "https://www.bro.org/sphinx/scripts/base/protocols/sip/main.bro.html#type-SIP::Info", "fields": [{"field": "ts", "type": "time", "description": "Timestamp for when the request happened."}, {"field": "uid", "type": "string", "description": "Unique ID for the connection."}, {"field": "id", "type": "conn_id", "description": "The connections 4-tuple of endpoint addresses/ports."}, {"field": "trans_depth", "type": "count", "description": "Represents the pipelined depth into the connection of this request/response transaction."}, {"field": "method", "type": "string", "description": "Verb used in the SIP request (INVITE, REGISTER etc.)."}, {"field": "uri", "type": "string", "description": "URI used in the request."}, {"field": "date", "type": "string", "description": "Contents of the Date: header from the client"}, {"field": "request_from", "type": "string", "description": "Contents of the request From: header Note: The tag= value thats usually appended to the sender is stripped off and not logged."}, {"field": "request_to", "type": "string", "description": "Contents of the To: header"}, {"field": "response_from", "type": "string", "description": "Contents of the response From: header Note: The tag= value thats usually appended to the sender is stripped off and not logged."}, {"field": "response_to", "type": "string", "description": "Contents of the response To: header"}, {"field": "reply_to", "type": "string", "description": "Contents of the Reply-To: header"}, {"field": "call_id", "type": "string", "description": "Contents of the Call-ID: header from the client"}, {"field": "seq", "type": "string", "description": "Contents of the CSeq: header from the client"}, {"field": "subject", "type": "string", "description": "Contents of the Subject: header from the client"}, {"field": "request_path", "type": "vector", "description": "The client message transmission path, as extracted from the headers."}, {"field": "response_path", "type": "vector", "description": "The server message transmission path, as extracted from the headers."}, {"field": "user_agent", "type": "string", "description": "Contents of the User-Agent: header from the client"}, {"field": "status_code", "type": "count", "description": "Status code returned by the server."}, {"field": "status_msg", "type": "string", "description": "Status message returned by the server."}, {"field": "warning", "type": "string", "description": "Contents of the Warning: header"}, {"field": "request_body_len", "type": "count", "description": "Contents of the Content-Length: header from the client"}, {"field": "response_body_len", "type": "count", "description": "Contents of the Content-Length: header from the server"}, {"field": "content_type", "type": "string", "description": "Contents of the Content-Type: header from the server"}], "file": "sip.log", "pattern": {"pattern": "%{NUMBER:ts}\\t%{NOTSPACE:uid}\\t%{IP:orig_h}\\t%{INT:orig_p}\\t%{IP:resp_h}\\t%{INT:resp_p}\\t%{INT:trans_depth}\\t%{GREEDYDATA:method}\\t%{GREEDYDATA:uri}\\t%{GREEDYDATA:date}\\t%{GREEDYDATA:request_from}\\t%{GREEDYDATA:request_to}\\t%{GREEDYDATA:response_from}\\t%{GREEDYDATA:response_to}\\t%{GREEDYDATA:reply_to}\\t%{GREEDYDATA:call_id}\\t%{GREEDYDATA:seq}\\t%{GREEDYDATA:subject}\\t%{GREEDYDATA:request_path}\\t%{GREEDYDATA:response_path}\\t%{GREEDYDATA:user_agent}\\t%{INT:status_code}\\t%{GREEDYDATA:status_msg}\\t%{GREEDYDATA:warning}\\t%{INT:request_body_len}\\t%{INT:response_body_len}\\t%{GREEDYDATA:content_type}", "name": "BRO_SIP"}, "log_type": "sip"}, {"description": "SMB commands", "url": "https://www.bro.org/sphinx/scripts/policy/protocols/smb/main.bro.html#type-SMB::CmdInfo", "fields": [{"field": "ts", "type": "time", "description": "Timestamp of the command request."}, {"field": "uid", "type": "string", "description": "Unique ID of the connection the request was sent over."}, {"field": "id", "type": "conn_id", "description": "ID of the connection the request was sent over."}, {"field": "command", "type": "string", "description": "The command sent by the client."}, {"field": "sub_command", "type": "string", "description": "The subcommand sent by the client, if present."}, {"field": "argument", "type": "string", "description": "Command argument sent by the client, if any."}, {"field": "status", "type": "string", "description": "Server reply to the clients command."}, {"field": "rtt", "type": "interval", "description": "Round trip time from the request to the response."}, {"field": "version", "type": "string", "description": "Version of SMB for the command."}, {"field": "username", "type": "string", "description": "Authenticated username, if available."}, {"field": "tree", "type": "string", "description": "If this is related to a tree, this is the tree that was used for the current command."}, {"field": "tree_service", "type": "string", "description": "The type of tree (disk share, printer share, named pipe, etc.)."}, {"field": "referenced_file.ts", "type": "time", "description": "Time when the file was first discovered."}, {"field": "referenced_file.uid", "type": "string", "description": "Unique ID of the connection the file was sent over."}, {"field": "referenced_file.id", "type": "conn_id", "description": "ID of the connection the file was sent over."}, {"field": "referenced_file.fuid", "type": "string", "description": "Unique ID of the file."}, {"field": "referenced_file.action", "type": "SMB::Action", "description": "Action this log record represents."}, {"field": "referenced_file.path", "type": "string", "description": "Path pulled from the tree this file was transferred to or from."}, {"field": "referenced_file.name", "type": "string", "description": "Filename if one was seen."}, {"field": "referenced_file.size", "type": "count", "description": "Total size of the file."}, {"field": "referenced_file.prev_name", "type": "string", "description": "If the rename action was seen, this will be the files previous name."}, {"field": "referenced_file.times", "type": "SMB::MACTimes", "description": "Last time this file was modified."}, {"field": "referenced_file.fid", "type": "count", "description": "ID referencing this file."}, {"field": "referenced_file.uuid", "type": "string", "description": "UUID referencing this file if DCE/RPC."}, {"field": "referenced_tree.ts", "type": "time", "description": "Time when the tree was mapped."}, {"field": "referenced_tree.uid", "type": "string", "description": "Unique ID of the connection the tree was mapped over."}, {"field": "referenced_tree.id", "type": "conn_id", "description": "ID of the connection the tree was mapped over."}, {"field": "referenced_tree.path", "type": "string", "description": "Name of the tree path."}, {"field": "referenced_tree.service", "type": "string", "description": "The type of resource of the tree (disk share, printer share, named pipe, etc.)."}, {"field": "referenced_tree.native_file_system", "type": "string", "description": "File system of the tree."}, {"field": "referenced_tree.share_type", "type": "string", "description": "If this is SMB2, a share type will be included.  For SMB1, the type of share will be deduced and included as well."}, {"field": "smb1_offered_dialects", "type": "string_vec", "description": "(present if policy/protocols/smb/smb1-main.bro is loaded)"}, {"field": "smb2_offered_dialects", "type": "index_vec", "description": "(present if policy/protocols/smb/smb2-main.bro is loaded)"}], "file": "smb_cmd.log", "pattern": {"pattern": "%{NUMBER:ts}\\t%{NOTSPACE:uid}\\t%{IP:orig_h}\\t%{INT:orig_p}\\t%{IP:resp_h}\\t%{INT:resp_p}\\t%{GREEDYDATA:command}\\t%{GREEDYDATA:sub_command}\\t%{GREEDYDATA:argument}\\t%{GREEDYDATA:status}\\t%{GREEDYDATA:rtt}\\t%{GREEDYDATA:version}\\t%{GREEDYDATA:username}\\t%{GREEDYDATA:tree}\\t%{GREEDYDATA:tree_service}\\t%{NUMBER:referenced_file.ts}\\t%{NOTSPACE:referenced_file.uid}\\t%{NOTSPACE:referenced_file.id}\\t%{NOTSPACE:referenced_file.fuid}\\t%{GREEDYDATA:referenced_file.action}\\t%{GREEDYDATA:referenced_file.path}\\t%{GREEDYDATA:referenced_file.name}\\t%{INT:referenced_file.size}\\t%{GREEDYDATA:referenced_file.prev_name}\\t%{GREEDYDATA:referenced_file.times}\\t%{INT:referenced_file.fid}\\t%{NOTSPACE:referenced_file.uuid}\\t%{NUMBER:referenced_tree.ts}\\t%{NOTSPACE:referenced_tree.uid}\\t%{NOTSPACE:referenced_tree.id}\\t%{GREEDYDATA:referenced_tree.path}\\t%{GREEDYDATA:referenced_tree.service}\\t%{GREEDYDATA:referenced_tree.native_file_system}\\t%{GREEDYDATA:referenced_tree.share_type}\\t%{GREEDYDATA:smb1_offered_dialects}\\t%{GREEDYDATA:smb2_offered_dialects}", "name": "BRO_SMB_CMD"}, "log_type": "smb_cmd"}, {"description": "SMB files", "url": "https://www.bro.org/sphinx/scripts/policy/protocols/smb/main.bro.html#type-SMB::FileInfo", "fields": [{"field": "ts", "type": "time", "description": "Time when the file was first discovered."}, {"field": "uid", "type": "string", "description": "Unique ID of the connection the file was sent over."}, {"field": "id", "type": "conn_id", "description": "ID of the connection the file was sent over."}, {"field": "fuid", "type": "string", "description": "Unique ID of the file."}, {"field": "action", "type": "SMB::Action", "description": ""}, {"field": "path", "type": "string", "description": "Path pulled from the tree this file was transferred to or from."}, {"field": "name", "type": "string", "description": "Filename if one was seen."}, {"field": "size", "type": "count", "description": "Total size of the file."}, {"field": "prev_name", "type": "string", "description": "If the rename action was seen, this will be the files previous name."}, {"field": "times.modified", "type": "time", "description": "The time when data was last written to the file."}, {"field": "times.accessed", "type": "time", "description": "The time when the file was last accessed."}, {"field": "times.created", "type": "time", "description": "The time the file was created."}, {"field": "times.changed", "type": "time", "description": "The time when the file was last modified."}, {"field": "fid", "type": "count", "description": "ID referencing this file."}, {"field": "uuid", "type": "string", "description": "UUID referencing this file if DCE/RPC."}], "file": "smb_files.log", "pattern": {"pattern": "%{NUMBER:ts}\\t%{NOTSPACE:uid}\\t%{IP:orig_h}\\t%{INT:orig_p}\\t%{IP:resp_h}\\t%{INT:resp_p}\\t%{NOTSPACE:fuid}\\t%{GREEDYDATA:action}\\t%{GREEDYDATA:path}\\t%{GREEDYDATA:name}\\t%{INT:size}\\t%{GREEDYDATA:prev_name}\\t%{NUMBER:times.modified}\\t%{NUMBER:times.accessed}\\t%{NUMBER:times.created}\\t%{NUMBER:times.changed}\\t%{INT:fid}\\t%{NOTSPACE:uuid}", "name": "BRO_SMB_FILES"}, "log_type": "smb_files"}, {"description": "SMB trees", "url": "https://www.bro.org/sphinx/scripts/policy/protocols/smb/main.bro.html#type-SMB::TreeInfo", "fields": [{"field": "ts", "type": "time", "description": "Time when the tree was mapped."}, {"field": "uid", "type": "string", "description": "Unique ID of the connection the tree was mapped over."}, {"field": "id", "type": "conn_id", "description": "ID of the connection the tree was mapped over."}, {"field": "path", "type": "string", "description": "Name of the tree path."}, {"field": "service", "type": "string", "description": "The type of resource of the tree (disk share, printer share, named pipe, etc.)."}, {"field": "native_file_system", "type": "string", "description": "File system of the tree."}, {"field": "share_type", "type": "string", "description": "If this is SMB2, a share type will be included.  For SMB1, the type of share will be deduced and included as well."}], "file": "smb_mapping.log", "pattern": {"pattern": "%{NUMBER:ts}\\t%{NOTSPACE:uid}\\t%{IP:orig_h}\\t%{INT:orig_p}\\t%{IP:resp_h}\\t%{INT:resp_p}\\t%{GREEDYDATA:path}\\t%{GREEDYDATA:service}\\t%{GREEDYDATA:native_file_system}\\t%{GREEDYDATA:share_type}", "name": "BRO_SMB_MAPPING"}, "log_type": "smb_mapping"}, {"description": "SMTP transactions", "url": "https://www.bro.org/sphinx/scripts/base/protocols/smtp/main.bro.html#type-SMTP::Info", "fields": [{"field": "ts", "type": "time", "description": "Time when the message was first seen."}, {"field": "uid", "type": "string", "description": "Unique ID for the connection."}, {"field": "id", "type": "conn_id", "description": "The connections 4-tuple of endpoint addresses/ports."}, {"field": "trans_depth", "type": "count", "description": "A count to represent the depth of this message transaction in a single connection where multiple messages were transferred."}, {"field": "helo", "type": "string", "description": "Contents of the Helo header."}, {"field": "mailfrom", "type": "string", "description": "Email addresses found in the From header."}, {"field": "rcptto", "type": "set", "description": "Email addresses found in the Rcpt header."}, {"field": "date", "type": "string", "description": "Contents of the Date header."}, {"field": "from", "type": "string", "description": "Contents of the From header."}, {"field": "to", "type": "set", "description": "Contents of the To header."}, {"field": "cc", "type": "set", "description": "Contents of the CC header."}, {"field": "reply_to", "type": "string", "description": "Contents of the ReplyTo header."}, {"field": "msg_id", "type": "string", "description": "Contents of the MsgID header."}, {"field": "in_reply_to", "type": "string", "description": "Contents of the In-Reply-To header."}, {"field": "subject", "type": "string", "description": "Contents of the Subject header."}, {"field": "x_originating_ip", "type": "addr", "description": "Contents of the X-Originating-IP header."}, {"field": "first_received", "type": "string", "description": "Contents of the first Received header."}, {"field": "second_received", "type": "string", "description": "Contents of the second Received header."}, {"field": "last_reply", "type": "string", "description": "The last message that the server sent to the client."}, {"field": "path", "type": "vector", "description": "The message transmission path, as extracted from the headers."}, {"field": "user_agent", "type": "string", "description": "Value of the User-Agent header from the client."}, {"field": "tls", "type": "bool", "description": "Indicates that the connection has switched to using TLS."}, {"field": "process_received_from", "type": "bool", "description": "Indicates if the Received: from headers should still be processed."}, {"field": "has_client_activity", "type": "bool", "description": "Indicates if client activity has been seen, but not yet logged."}, {"field": "entity.filename", "type": "string", "description": "Filename for the entity if discovered from a header."}, {"field": "entity.excerpt", "type": "string", "description": "(present if policy/protocols/smtp/entities-excerpt.bro is loaded)"}, {"field": "fuids", "type": "vector", "description": "(present if base/protocols/smtp/files.bro is loaded)"}, {"field": "is_webmail", "type": "bool", "description": "(present if policy/protocols/smtp/software.bro is loaded)"}], "file": "smtp.log", "pattern": {"pattern": "%{NUMBER:ts}\\t%{NOTSPACE:uid}\\t%{IP:orig_h}\\t%{INT:orig_p}\\t%{IP:resp_h}\\t%{INT:resp_p}\\t%{INT:trans_depth}\\t%{GREEDYDATA:helo}\\t%{GREEDYDATA:mailfrom}\\t%{GREEDYDATA:rcptto}\\t%{GREEDYDATA:date}\\t%{GREEDYDATA:from}\\t%{GREEDYDATA:to}\\t%{GREEDYDATA:cc}\\t%{GREEDYDATA:reply_to}\\t%{GREEDYDATA:msg_id}\\t%{GREEDYDATA:in_reply_to}\\t%{GREEDYDATA:subject}\\t%{IP:x_originating_ip}\\t%{GREEDYDATA:first_received}\\t%{GREEDYDATA:second_received}\\t%{GREEDYDATA:last_reply}\\t%{GREEDYDATA:path}\\t%{GREEDYDATA:user_agent}\\t%{GREEDYDATA:tls}\\t%{GREEDYDATA:process_received_from}\\t%{GREEDYDATA:has_client_activity}\\t%{GREEDYDATA:entity.filename}\\t%{GREEDYDATA:entity.excerpt}\\t%{NOTSPACE:fuids}\\t%{GREEDYDATA:is_webmail}", "name": "BRO_SMTP"}, "log_type": "smtp"}, {"description": "SNMP messages", "url": "https://www.bro.org/sphinx/scripts/base/protocols/snmp/main.bro.html#type-SNMP::Info", "fields": [{"field": "ts", "type": "time", "description": "Timestamp of first packet belonging to the SNMP session."}, {"field": "uid", "type": "string", "description": "The unique ID for the connection."}, {"field": "id", "type": "conn_id", "description": "The connections 5-tuple of addresses/ports (ports inherently include transport protocol information)"}, {"field": "duration", "type": "interval", "description": "The amount of time between the first packet beloning to the SNMP session and the latest one seen."}, {"field": "version", "type": "string", "description": "The version of SNMP being used."}, {"field": "community", "type": "string", "description": "The community string of the first SNMP packet associated with the session.  This is used as part of SNMPs (v1 and v2c) administrative/security framework.  See RFC 1157 or RFC 1901."}, {"field": "get_requests", "type": "count", "description": "The number of variable bindings in GetRequest/GetNextRequest PDUs seen for the session."}, {"field": "get_bulk_requests", "type": "count", "description": "The number of variable bindings in GetBulkRequest PDUs seen for the session."}, {"field": "get_responses", "type": "count", "description": "The number of variable bindings in GetResponse/Response PDUs seen for the session."}, {"field": "set_requests", "type": "count", "description": "The number of variable bindings in SetRequest PDUs seen for the session."}, {"field": "display_string", "type": "string", "description": "A system description of the SNMP responder endpoint."}, {"field": "up_since", "type": "time", "description": "The time at which the SNMP responder endpoint claims its been up since."}], "file": "snmp.log", "pattern": {"pattern": "%{NUMBER:ts}\\t%{NOTSPACE:uid}\\t%{IP:orig_h}\\t%{INT:orig_p}\\t%{IP:resp_h}\\t%{INT:resp_p}\\t%{GREEDYDATA:duration}\\t%{GREEDYDATA:version}\\t%{GREEDYDATA:community}\\t%{INT:get_requests}\\t%{INT:get_bulk_requests}\\t%{INT:get_responses}\\t%{INT:set_requests}\\t%{GREEDYDATA:display_string}\\t%{NUMBER:up_since}", "name": "BRO_SNMP"}, "log_type": "snmp"}, {"description": "SOCKS proxy requests", "url": "https://www.bro.org/sphinx/scripts/base/protocols/socks/main.bro.html#type-SOCKS::Info", "fields": [{"field": "ts", "type": "time", "description": "Time when the proxy connection was first detected."}, {"field": "uid", "type": "string", "description": "Unique ID for the tunnel - may correspond to connection uid or be non-existent."}, {"field": "id", "type": "conn_id", "description": "The connections 4-tuple of endpoint addresses/ports."}, {"field": "version", "type": "count", "description": "Protocol version of SOCKS."}, {"field": "user", "type": "string", "description": "Username used to request a login to the proxy."}, {"field": "password", "type": "string", "description": "Password used to request a login to the proxy."}, {"field": "status", "type": "string", "description": "Server status for the attempt at using the proxy."}, {"field": "request.host", "type": "addr", "description": ""}, {"field": "request.name", "type": "string", "description": ""}, {"field": "request_p", "type": "port", "description": "Client requested port."}, {"field": "bound.host", "type": "addr", "description": ""}, {"field": "bound.name", "type": "string", "description": ""}, {"field": "bound_p", "type": "port", "description": "Server bound port."}], "file": "socks.log", "pattern": {"pattern": "%{NUMBER:ts}\\t%{NOTSPACE:uid}\\t%{IP:orig_h}\\t%{INT:orig_p}\\t%{IP:resp_h}\\t%{INT:resp_p}\\t%{INT:version}\\t%{GREEDYDATA:user}\\t%{GREEDYDATA:password}\\t%{GREEDYDATA:status}\\t%{IP:request.host}\\t%{GREEDYDATA:request.name}\\t%{INT:request_p}\\t%{IP:bound.host}\\t%{GREEDYDATA:bound.name}\\t%{INT:bound_p}", "name": "BRO_SOCKS"}, "log_type": "socks"}, {"description": "SSH connections", "url": "https://www.bro.org/sphinx/scripts/base/protocols/ssh/main.bro.html#type-SSH::Info", "fields": [{"field": "ts", "type": "time", "description": "Time when the SSH connection began."}, {"field": "uid", "type": "string", "description": "Unique ID for the connection."}, {"field": "id", "type": "conn_id", "description": "The connections 4-tuple of endpoint addresses/ports."}, {"field": "version", "type": "count", "description": "SSH major version (1 or 2)"}, {"field": "auth_success", "type": "bool", "description": "Authentication result (T=success, F=failure, unset=unknown)"}, {"field": "auth_attempts", "type": "count", "description": "The number of authentication attemps we observed. Theres always at least one, since some servers might support no authentication at all. Its important to note that not all of these are failures, since some servers require two-factor auth (e.g. password AND pubkey)"}, {"field": "direction", "type": "Direction", "description": "Direction of the connection. If the client was a local host logging into an external host, this would be OUTBOUND. INBOUND would be set for the opposite situation."}, {"field": "client", "type": "string", "description": "The clients version string"}, {"field": "server", "type": "string", "description": "The servers version string"}, {"field": "cipher_alg", "type": "string", "description": "The encryption algorithm in use"}, {"field": "mac_alg", "type": "string", "description": "The signing (MAC) algorithm in use"}, {"field": "compression_alg", "type": "string", "description": "The compression algorithm in use"}, {"field": "kex_alg", "type": "string", "description": "The key exchange algorithm in use"}, {"field": "host_key_alg", "type": "string", "description": "The server host keys algorithm"}, {"field": "host_key", "type": "string", "description": "The servers key fingerprint"}], "file": "ssh.log", "pattern": {"pattern": "%{NUMBER:ts}\\t%{NOTSPACE:uid}\\t%{IP:orig_h}\\t%{INT:orig_p}\\t%{IP:resp_h}\\t%{INT:resp_p}\\t%{INT:version}\\t%{GREEDYDATA:auth_success}\\t%{INT:auth_attempts}\\t%{GREEDYDATA:direction}\\t%{GREEDYDATA:client}\\t%{GREEDYDATA:server}\\t%{GREEDYDATA:cipher_alg}\\t%{GREEDYDATA:mac_alg}\\t%{GREEDYDATA:compression_alg}\\t%{GREEDYDATA:kex_alg}\\t%{GREEDYDATA:host_key_alg}\\t%{GREEDYDATA:host_key}", "name": "BRO_SSH"}, "log_type": "ssh"}, {"description": "SSL/TLS handshake info", "url": "https://www.bro.org/sphinx/scripts/base/protocols/ssl/main.bro.html#type-SSL::Info", "fields": [{"field": "ts", "type": "time", "description": "Time when the SSL connection was first detected."}, {"field": "uid", "type": "string", "description": "Unique ID for the connection."}, {"field": "id", "type": "conn_id", "description": "The connections 4-tuple of endpoint addresses/ports."}, {"field": "version_num", "type": "count", "description": "Numeric SSL/TLS version that the server chose."}, {"field": "version", "type": "string", "description": "SSL/TLS version that the server chose."}, {"field": "cipher", "type": "string", "description": "SSL/TLS cipher suite that the server chose."}, {"field": "curve", "type": "string", "description": "Elliptic curve the server chose when using ECDH/ECDHE."}, {"field": "server_name", "type": "string", "description": "Value of the Server Name Indicator SSL/TLS extension.  It indicates the server name that the client was requesting."}, {"field": "session_id", "type": "string", "description": "Session ID offered by the client for session resumption. Not used for logging."}, {"field": "resumed", "type": "bool", "description": "Flag to indicate if the session was resumed reusing the key material exchanged in an earlier connection."}, {"field": "client_ticket_empty_session_seen", "type": "bool", "description": "Flag to indicate if we saw a non-empty session ticket being sent by the client using an empty session ID. This value is used to determine if a session is being resumed. Its not logged."}, {"field": "client_key_exchange_seen", "type": "bool", "description": "Flag to indicate if we saw a client key exchange message sent by the client. This value is used to determine if a session is being resumed. Its not logged."}, {"field": "server_appdata", "type": "count", "description": "Count to track if the server already sent an application data packet for TLS 1.3. Used to track when a session was established."}, {"field": "client_appdata", "type": "bool", "description": "Flag to track if the client already sent an application data packet for TLS 1.3. Used to track when a session was established."}, {"field": "last_alert", "type": "string", "description": "Last alert that was seen during the connection."}, {"field": "next_protocol", "type": "string", "description": "Next protocol the server chose using the application layer next protocol extension, if present."}, {"field": "analyzer_id", "type": "count", "description": "The analyzer ID used for the analyzer instance attached to each connection.  It is not used for logging since its a meaningless arbitrary number."}, {"field": "established", "type": "bool", "description": "Flag to indicate if this ssl session has been established successfully, or if it was aborted during the handshake."}, {"field": "logged", "type": "bool", "description": "Flag to indicate if this record already has been logged, to prevent duplicates."}], "file": "ssl.log", "pattern": {"pattern": "%{NUMBER:ts}\\t%{NOTSPACE:uid}\\t%{IP:orig_h}\\t%{INT:orig_p}\\t%{IP:resp_h}\\t%{INT:resp_p}\\t%{INT:version_num}\\t%{GREEDYDATA:version}\\t%{GREEDYDATA:cipher}\\t%{GREEDYDATA:curve}\\t%{GREEDYDATA:server_name}\\t%{GREEDYDATA:session_id}\\t%{GREEDYDATA:resumed}\\t%{GREEDYDATA:client_ticket_empty_session_seen}\\t%{GREEDYDATA:client_key_exchange_seen}\\t%{INT:server_appdata}\\t%{GREEDYDATA:client_appdata}\\t%{GREEDYDATA:last_alert}\\t%{GREEDYDATA:next_protocol}\\t%{INT:analyzer_id}\\t%{GREEDYDATA:established}\\t%{GREEDYDATA:logged}", "name": "BRO_SSL"}, "log_type": "ssl"}, {"description": "Syslog messages", "url": "https://www.bro.org/sphinx/scripts/base/protocols/syslog/main.bro.html#type-Syslog::Info", "fields": [{"field": "ts", "type": "time", "description": "Timestamp when the syslog message was seen."}, {"field": "uid", "type": "string", "description": "Unique ID for the connection."}, {"field": "id", "type": "conn_id", "description": "The connections 4-tuple of endpoint addresses/ports."}, {"field": "proto", "type": "transport_proto", "description": "Protocol over which the message was seen."}, {"field": "facility", "type": "string", "description": "Syslog facility for the message."}, {"field": "severity", "type": "string", "description": "Syslog severity for the message."}, {"field": "message", "type": "string", "description": "The plain text message."}], "file": "syslog.log", "pattern": {"pattern": "%{NUMBER:ts}\\t%{NOTSPACE:uid}\\t%{IP:orig_h}\\t%{INT:orig_p}\\t%{IP:resp_h}\\t%{INT:resp_p}\\t%{WORD:proto}\\t%{GREEDYDATA:facility}\\t%{GREEDYDATA:severity}\\t%{GREEDYDATA:message}", "name": "BRO_SYSLOG"}, "log_type": "syslog"}, {"description": "Tunneling protocol events", "url": "https://www.bro.org/sphinx/scripts/base/frameworks/tunnels/main.bro.html#type-Tunnel::Info", "fields": [{"field": "ts", "type": "time", "description": "Time at which some tunnel activity occurred."}, {"field": "uid", "type": "string", "description": "The unique identifier for the tunnel, which may correspond to a connections uid field for non-IP-in-IP tunnels. This is optional because there could be numerous connections for payload proxies like SOCKS but we should treat it as a single tunnel."}, {"field": "id", "type": "conn_id", "description": "The tunnel connection 4-tuple of endpoint addresses/ports. For an IP tunnel, the ports will be 0."}, {"field": "tunnel_type", "type": "Tunnel::Type", "description": ""}, {"field": "action", "type": "Tunnel::Action", "description": ""}], "file": "tunnel.log", "pattern": {"pattern": "%{NUMBER:ts}\\t%{NOTSPACE:uid}\\t%{IP:orig_h}\\t%{INT:orig_p}\\t%{IP:resp_h}\\t%{INT:resp_p}\\t%{GREEDYDATA:tunnel_type}\\t%{GREEDYDATA:action}", "name": "BRO_TUNNEL"}, "log_type": "tunnel"}, {"description": "File analysis results", "url": "https://www.bro.org/sphinx/scripts/base/frameworks/files/main.bro.html#type-Files::Info", "fields": [{"field": "ts", "type": "time", "description": "The time when the file was first seen."}, {"field": "fuid", "type": "string", "description": "An identifier associated with a single file."}, {"field": "tx_hosts", "type": "set", "description": "If this file was transferred over a network connection this should show the host or hosts that the data sourced from."}, {"field": "rx_hosts", "type": "set", "description": "If this file was transferred over a network connection this should show the host or hosts that the data traveled to."}, {"field": "conn_uids", "type": "set", "description": "Connection UIDs over which the file was transferred."}, {"field": "source", "type": "string", "description": "An identification of the source of the file data.  E.g. it may be a network protocol over which it was transferred, or a local file path which was read, or some other input source."}, {"field": "depth", "type": "count", "description": "A value to represent the depth of this file in relation to its source.  In SMTP, it is the depth of the MIME attachment on the message.  In HTTP, it is the depth of the request within the TCP connection."}, {"field": "analyzers", "type": "set", "description": "A set of analysis types done during the file analysis."}, {"field": "mime_type", "type": "string", "description": "A mime type provided by the strongest file magic signature match against the bof_buffer field of fa_file, or in the cases where no buffering of the beginning of file occurs, an initial guess of the mime type based on the first data seen."}, {"field": "filename", "type": "string", "description": "A filename for the file if one is available from the source for the file.  These will frequently come from Content-Disposition headers in network protocols."}, {"field": "duration", "type": "interval", "description": "The duration the file was analyzed for."}, {"field": "local_orig", "type": "bool", "description": "If the source of this file is a network connection, this field indicates if the data originated from the local network or not as determined by the configured Site::local_nets."}, {"field": "is_orig", "type": "bool", "description": "If the source of this file is a network connection, this field indicates if the file is being sent by the originator of the connection or the responder."}, {"field": "seen_bytes", "type": "count", "description": "Number of bytes provided to the file analysis engine for the file."}, {"field": "total_bytes", "type": "count", "description": "Total number of bytes that are supposed to comprise the full file."}, {"field": "missing_bytes", "type": "count", "description": "The number of bytes in the file stream that were completely missed during the process of analysis e.g. due to dropped packets."}, {"field": "overflow_bytes", "type": "count", "description": "The number of bytes in the file stream that were not delivered to stream file analyzers.  This could be overlapping bytes or bytes that couldnt be reassembled."}, {"field": "timedout", "type": "bool", "description": "Whether the file analysis timed out at least once for the file."}, {"field": "parent_fuid", "type": "string", "description": "Identifier associated with a container file from which this one was extracted as part of the file analysis."}, {"field": "md5", "type": "string", "description": "(present if base/files/hash/main.bro is loaded)"}, {"field": "sha1", "type": "string", "description": "(present if base/files/hash/main.bro is loaded)"}, {"field": "sha256", "type": "string", "description": "(present if base/files/hash/main.bro is loaded)"}, {"field": "x509.ts", "type": "time", "description": "Current timestamp."}, {"field": "x509.id", "type": "string", "description": "File id of this certificate."}, {"field": "x509.certificate", "type": "X509::Certificate", "description": "Basic information about the certificate."}, {"field": "x509.handle", "type": "opaque", "description": "The opaque wrapping the certificate. Mainly used for the verify operations."}, {"field": "x509.extensions", "type": "vector", "description": "All extensions that were encountered in the certificate."}, {"field": "x509.san", "type": "X509::SubjectAlternativeName", "description": "Subject alternative name extension of the certificate."}, {"field": "x509.basic_constraints", "type": "X509::BasicConstraints", "description": "Basic constraints extension of the certificate."}, {"field": "x509.logcert", "type": "bool", "description": "(present if policy/protocols/ssl/log-hostcerts-only.bro is loaded)"}, {"field": "extracted", "type": "string", "description": "(present if base/files/extract/main.bro is loaded)"}, {"field": "entropy", "type": "double", "description": "(present if policy/frameworks/files/entropy-test-all-files.bro is loaded)"}], "file": "files.log", "pattern": {"pattern": "%{NUMBER:ts}\\t%{NOTSPACE:fuid}\\t%{GREEDYDATA:tx_hosts}\\t%{GREEDYDATA:rx_hosts}\\t%{NOTSPACE:conn_uids}\\t%{GREEDYDATA:source}\\t%{INT:depth}\\t%{GREEDYDATA:analyzers}\\t%{GREEDYDATA:mime_type}\\t%{GREEDYDATA:filename}\\t%{GREEDYDATA:duration}\\t%{GREEDYDATA:local_orig}\\t%{GREEDYDATA:is_orig}\\t%{INT:seen_bytes}\\t%{INT:total_bytes}\\t%{INT:missing_bytes}\\t%{INT:overflow_bytes}\\t%{GREEDYDATA:timedout}\\t%{NOTSPACE:parent_fuid}\\t%{GREEDYDATA:md5}\\t%{GREEDYDATA:sha1}\\t%{GREEDYDATA:sha256}\\t%{NUMBER:x509.ts}\\t%{GREEDYDATA:x509.id}\\t%{GREEDYDATA:x509.certificate}\\t%{GREEDYDATA:x509.handle}\\t%{GREEDYDATA:x509.extensions}\\t%{GREEDYDATA:x509.san}\\t%{GREEDYDATA:x509.basic_constraints}\\t%{GREEDYDATA:x509.logcert}\\t%{GREEDYDATA:extracted}\\t%{GREEDYDATA:entropy}", "name": "BRO_FILES"}, "log_type": "files"}, {"description": "Portable Executable (PE)", "url": "https://www.bro.org/sphinx/scripts/base/files/pe/main.bro.html#type-PE::Info", "fields": [{"field": "ts", "type": "time", "description": "Current timestamp."}, {"field": "id", "type": "string", "description": "File id of this portable executable file."}, {"field": "machine", "type": "string", "description": "The target machine that the file was compiled for."}, {"field": "compile_ts", "type": "time", "description": "The time that the file was created at."}, {"field": "os", "type": "string", "description": "The required operating system."}, {"field": "subsystem", "type": "string", "description": "The subsystem that is required to run this file."}, {"field": "is_exe", "type": "bool", "description": "Is the file an executable, or just an object file?"}, {"field": "is_64bit", "type": "bool", "description": "Is the file a 64-bit executable?"}, {"field": "uses_aslr", "type": "bool", "description": "Does the file support Address Space Layout Randomization?"}, {"field": "uses_dep", "type": "bool", "description": "Does the file support Data Execution Prevention?"}, {"field": "uses_code_integrity", "type": "bool", "description": "Does the file enforce code integrity checks?"}, {"field": "uses_seh", "type": "bool", "description": "Does the file use structured exception handing?"}, {"field": "has_import_table", "type": "bool", "description": "Does the file have an import table?"}, {"field": "has_export_table", "type": "bool", "description": "Does the file have an export table?"}, {"field": "has_cert_table", "type": "bool", "description": "Does the file have an attribute certificate table?"}, {"field": "has_debug_data", "type": "bool", "description": "Does the file have a debug table?"}, {"field": "section_names", "type": "vector", "description": "The names of the sections, in order."}], "file": "pe.log", "pattern": {"pattern": "%{NUMBER:ts}\\t%{IP:orig_h}\\t%{INT:orig_p}\\t%{IP:resp_h}\\t%{INT:resp_p}\\t%{GREEDYDATA:machine}\\t%{NUMBER:compile_ts}\\t%{GREEDYDATA:os}\\t%{GREEDYDATA:subsystem}\\t%{GREEDYDATA:is_exe}\\t%{GREEDYDATA:is_64bit}\\t%{GREEDYDATA:uses_aslr}\\t%{GREEDYDATA:uses_dep}\\t%{GREEDYDATA:uses_code_integrity}\\t%{GREEDYDATA:uses_seh}\\t%{GREEDYDATA:has_import_table}\\t%{GREEDYDATA:has_export_table}\\t%{GREEDYDATA:has_cert_table}\\t%{GREEDYDATA:has_debug_data}\\t%{GREEDYDATA:section_names}", "name": "BRO_PE"}, "log_type": "pe"}, {"description": "X.509 certificate info", "url": "https://www.bro.org/sphinx/scripts/base/files/x509/main.bro.html#type-X509::Info", "fields": [{"field": "ts", "type": "time", "description": "Current timestamp."}, {"field": "id", "type": "string", "description": "File id of this certificate."}, {"field": "certificate.version", "type": "count", "description": "Version number."}, {"field": "certificate.serial", "type": "string", "description": "Serial number."}, {"field": "certificate.subject", "type": "string", "description": "Subject."}, {"field": "certificate.issuer", "type": "string", "description": "Issuer."}, {"field": "certificate.cn", "type": "string", "description": "Last (most specific) common name."}, {"field": "certificate.not_valid_before", "type": "time", "description": "Timestamp before when certificate is not valid."}, {"field": "certificate.not_valid_after", "type": "time", "description": "Timestamp after when certificate is not valid."}, {"field": "certificate.key_alg", "type": "string", "description": "Name of the key algorithm"}, {"field": "certificate.sig_alg", "type": "string", "description": "Name of the signature algorithm"}, {"field": "certificate.key_type", "type": "string", "description": "Key type, if key parseable by openssl (either rsa, dsa or ec)"}, {"field": "certificate.key_length", "type": "count", "description": "Key length in bits"}, {"field": "certificate.exponent", "type": "string", "description": "Exponent, if RSA-certificate"}, {"field": "certificate.curve", "type": "string", "description": "Curve, if EC-certificate"}, {"field": "handle", "type": "opaque", "description": "The opaque wrapping the certificate. Mainly used for the verify operations."}, {"field": "extensions", "type": "vector", "description": "All extensions that were encountered in the certificate."}, {"field": "san.dns", "type": "string_vec", "description": "List of DNS entries in SAN"}, {"field": "san.uri", "type": "string_vec", "description": "List of URI entries in SAN"}, {"field": "san.email", "type": "string_vec", "description": "List of email entries in SAN"}, {"field": "san.ip", "type": "addr_vec", "description": "List of IP entries in SAN"}, {"field": "san.other_fields", "type": "bool", "description": "True if the certificate contained other, not recognized or parsed name fields"}, {"field": "basic_constraints.ca", "type": "bool", "description": "CA flag set?"}, {"field": "basic_constraints.path_len", "type": "count", "description": "Maximum path length"}, {"field": "logcert", "type": "bool", "description": "(present if policy/protocols/ssl/log-hostcerts-only.bro is loaded)"}], "file": "x509.log", "pattern": {"pattern": "%{NUMBER:ts}\\t%{IP:orig_h}\\t%{INT:orig_p}\\t%{IP:resp_h}\\t%{INT:resp_p}\\t%{INT:certificate.version}\\t%{GREEDYDATA:certificate.serial}\\t%{GREEDYDATA:certificate.subject}\\t%{GREEDYDATA:certificate.issuer}\\t%{GREEDYDATA:certificate.cn}\\t%{NUMBER:certificate.not_valid_before}\\t%{NUMBER:certificate.not_valid_after}\\t%{GREEDYDATA:certificate.key_alg}\\t%{GREEDYDATA:certificate.sig_alg}\\t%{GREEDYDATA:certificate.key_type}\\t%{INT:certificate.key_length}\\t%{GREEDYDATA:certificate.exponent}\\t%{GREEDYDATA:certificate.curve}\\t%{GREEDYDATA:handle}\\t%{GREEDYDATA:extensions}\\t%{GREEDYDATA:san.dns}\\t%{GREEDYDATA:san.uri}\\t%{GREEDYDATA:san.email}\\t%{GREEDYDATA:san.ip}\\t%{GREEDYDATA:san.other_fields}\\t%{GREEDYDATA:basic_constraints.ca}\\t%{INT:basic_constraints.path_len}\\t%{GREEDYDATA:logcert}", "name": "BRO_X509"}, "log_type": "x509"}, {"description": "NetControl actions", "url": "https://www.bro.org/sphinx/scripts/base/frameworks/netcontrol/main.bro.html#type-NetControl::Info", "fields": [{"field": "ts", "type": "time", "description": "Time at which the recorded activity occurred."}, {"field": "rule_id", "type": "string", "description": "ID of the rule; unique during each Bro run."}, {"field": "category", "type": "NetControl::InfoCategory", "description": ""}, {"field": "cmd", "type": "string", "description": "The command the log entry is about."}, {"field": "state", "type": "NetControl::InfoState", "description": ""}, {"field": "action", "type": "string", "description": "String describing an action the entry is about."}, {"field": "target", "type": "NetControl::TargetType", "description": ""}, {"field": "entity_type", "type": "string", "description": "Type of the entity the log entry is about."}, {"field": "entity", "type": "string", "description": "String describing the entity the log entry is about."}, {"field": "mod", "type": "string", "description": "String describing the optional modification of the entry (e.h. redirect)"}, {"field": "msg", "type": "string", "description": "String with an additional message."}, {"field": "priority", "type": "int", "description": "Number describing the priority of the log entry."}, {"field": "expire", "type": "interval", "description": "Expiry time of the log entry."}, {"field": "location", "type": "string", "description": "Location where the underlying action was triggered."}, {"field": "plugin", "type": "string", "description": "Plugin triggering the log entry."}], "file": "netcontrol.log", "pattern": {"pattern": "%{NUMBER:ts}\\t%{GREEDYDATA:rule_id}\\t%{GREEDYDATA:category}\\t%{GREEDYDATA:cmd}\\t%{GREEDYDATA:state}\\t%{GREEDYDATA:action}\\t%{GREEDYDATA:target}\\t%{GREEDYDATA:entity_type}\\t%{GREEDYDATA:entity}\\t%{GREEDYDATA:mod}\\t%{GREEDYDATA:msg}\\t%{INT:priority}\\t%{GREEDYDATA:expire}\\t%{GREEDYDATA:location}\\t%{GREEDYDATA:plugin}", "name": "BRO_NETCONTROL"}, "log_type": "netcontrol"}, {"description": "NetControl actions", "url": "https://www.bro.org/sphinx/scripts/base/frameworks/netcontrol/drop.bro.html#type-NetControl::DropInfo", "fields": [{"field": "ts", "type": "time", "description": "Time at which the recorded activity occurred."}, {"field": "rule_id", "type": "string", "description": "ID of the rule; unique during each Bro run."}, {"field": "orig_h", "type": "addr", "description": "The originators IP address."}, {"field": "orig_p", "type": "port", "description": "The originators port number."}, {"field": "resp_h", "type": "addr", "description": "The responders IP address."}, {"field": "resp_p", "type": "port", "description": "The responders port number."}, {"field": "expire", "type": "interval", "description": "Expiry time of the shunt."}, {"field": "location", "type": "string", "description": "Location where the underlying action was triggered."}], "file": "netcontrol_drop.log", "pattern": {"pattern": "%{NUMBER:ts}\\t%{GREEDYDATA:rule_id}\\t%{IP:orig_h}\\t%{INT:orig_p}\\t%{IP:resp_h}\\t%{INT:resp_p}\\t%{GREEDYDATA:expire}\\t%{GREEDYDATA:location}", "name": "BRO_NETCONTROL_DROP"}, "log_type": "netcontrol_drop"}, {"description": "NetControl shunt actions", "url": "https://www.bro.org/sphinx/scripts/base/frameworks/netcontrol/shunt.bro.html#type-NetControl::ShuntInfo", "fields": [{"field": "ts", "type": "time", "description": "Time at which the recorded activity occurred."}, {"field": "rule_id", "type": "string", "description": "ID of the rule; unique during each Bro run."}, {"field": "f", "type": "flow_id", "description": "Flow ID of the shunted flow."}, {"field": "expire", "type": "interval", "description": "Expiry time of the shunt."}, {"field": "location", "type": "string", "description": "Location where the underlying action was triggered."}], "file": "netcontrol_shunt.log", "pattern": {"pattern": "%{NUMBER:ts}\\t%{GREEDYDATA:rule_id}\\t%{GREEDYDATA:f}\\t%{GREEDYDATA:expire}\\t%{GREEDYDATA:location}", "name": "BRO_NETCONTROL_SHUNT"}, "log_type": "netcontrol_shunt"}, {"description": "NetControl catch and release actions", "url": "https://www.bro.org/sphinx/scripts/base/frameworks/netcontrol/catch-and-release.bro.html#type-NetControl::CatchReleaseInfo", "fields": [{"field": "ts", "type": "time", "description": "The absolute time indicating when the action for this log-line occured."}, {"field": "rule_id", "type": "string", "description": "The rule id that this log line refers to."}, {"field": "ip", "type": "addr", "description": "The IP address that this line refers to."}, {"field": "action", "type": "NetControl::CatchReleaseActions", "description": ""}, {"field": "block_interval", "type": "interval", "description": "The current block_interaval (for how long the address is blocked)."}, {"field": "watch_interval", "type": "interval", "description": "The current watch_interval (for how long the address will be watched and re-block if it reappears)."}, {"field": "blocked_until", "type": "time", "description": "The absolute time until which the address is blocked."}, {"field": "watched_until", "type": "time", "description": "The absolute time until which the address will be monitored."}, {"field": "num_blocked", "type": "count", "description": "Number of times that this address was blocked in the current cycle."}, {"field": "location", "type": "string", "description": "The user specified location string."}, {"field": "message", "type": "string", "description": "Additional informational string by the catch and release framework about this log-line."}], "file": "netcontrol_catch_release.log", "pattern": {"pattern": "%{NUMBER:ts}\\t%{GREEDYDATA:rule_id}\\t%{IP:ip}\\t%{GREEDYDATA:action}\\t%{GREEDYDATA:block_interval}\\t%{GREEDYDATA:watch_interval}\\t%{NUMBER:blocked_until}\\t%{NUMBER:watched_until}\\t%{INT:num_blocked}\\t%{GREEDYDATA:location}\\t%{GREEDYDATA:message}", "name": "BRO_NETCONTROL_CATCH_RELEASE"}, "log_type": "netcontrol_catch_release"}, {"description": "OpenFlow debug log", "url": "https://www.bro.org/sphinx/scripts/base/frameworks/openflow/plugins/log.bro.html#type-OpenFlow::Info", "fields": [{"field": "ts", "type": "time", "description": "Network time."}, {"field": "dpid", "type": "count", "description": "OpenFlow switch datapath id."}, {"field": "match.in_port", "type": "count", "description": ""}, {"field": "match.dl_src", "type": "string", "description": ""}, {"field": "match.dl_dst", "type": "string", "description": ""}, {"field": "match.dl_vlan", "type": "count", "description": ""}, {"field": "match.dl_vlan_pcp", "type": "count", "description": ""}, {"field": "match.dl_type", "type": "count", "description": ""}, {"field": "match.nw_tos", "type": "count", "description": ""}, {"field": "match.nw_proto", "type": "count", "description": ""}, {"field": "match.nw_src", "type": "subnet", "description": ""}, {"field": "match.nw_dst", "type": "subnet", "description": ""}, {"field": "match.tp_src", "type": "count", "description": ""}, {"field": "match.tp_dst", "type": "count", "description": ""}, {"field": "flow_mod.cookie", "type": "count", "description": "Opaque controller-issued identifier."}, {"field": "flow_mod.table_id", "type": "count", "description": "Table to put the flow in. OFPTT_ALL can be used for delete, to delete flows from all matching tables."}, {"field": "flow_mod.command", "type": "OpenFlow::ofp_flow_mod_command", "description": "One of OFPFC_*."}, {"field": "flow_mod.idle_timeout", "type": "count", "description": "Idle time before discarding (seconds)."}, {"field": "flow_mod.hard_timeout", "type": "count", "description": "Max time before discarding (seconds)."}, {"field": "flow_mod.priority", "type": "count", "description": "Priority level of flow entry."}, {"field": "flow_mod.out_port", "type": "count", "description": "For OFPFC_DELETE* commands, require matching entried to include this as an output port/group. OFPP_ANY/OFPG_ANY means no restrictions."}], "file": "openflow.log", "pattern": {"pattern": "%{NUMBER:ts}\\t%{INT:dpid}\\t%{INT:match.in_port}\\t%{GREEDYDATA:match.dl_src}\\t%{GREEDYDATA:match.dl_dst}\\t%{INT:match.dl_vlan}\\t%{INT:match.dl_vlan_pcp}\\t%{INT:match.dl_type}\\t%{INT:match.nw_tos}\\t%{INT:match.nw_proto}\\t%{GREEDYDATA:match.nw_src}\\t%{GREEDYDATA:match.nw_dst}\\t%{INT:match.tp_src}\\t%{INT:match.tp_dst}\\t%{INT:flow_mod.cookie}\\t%{INT:flow_mod.table_id}\\t%{GREEDYDATA:flow_mod.command}\\t%{INT:flow_mod.idle_timeout}\\t%{INT:flow_mod.hard_timeout}\\t%{INT:flow_mod.priority}\\t%{INT:flow_mod.out_port}", "name": "BRO_OPENFLOW"}, "log_type": "openflow"}, {"description": "Intelligence data matches", "url": "https://www.bro.org/sphinx/scripts/base/frameworks/intel/main.bro.html#type-Intel::Info", "fields": [{"field": "ts", "type": "time", "description": "Timestamp when the data was discovered."}, {"field": "uid", "type": "string", "description": "If a connection was associated with this intelligence hit, this is the uid for the connection"}, {"field": "id", "type": "conn_id", "description": "If a connection was associated with this intelligence hit, this is the conn_id for the connection."}, {"field": "seen.indicator", "type": "string", "description": "The string if the data is about a string."}, {"field": "seen.indicator_type", "type": "Intel::Type", "description": "The type of data that the indicator represents."}, {"field": "seen.host", "type": "addr", "description": "If the indicator type was Intel::ADDR, then this field will be present."}, {"field": "seen.where", "type": "Intel::Where", "description": "Where the data was discovered."}, {"field": "seen.node", "type": "string", "description": "The name of the node where the match was discovered."}, {"field": "seen.conn", "type": "connection", "description": "If the data was discovered within a connection, the connection record should go here to give context to the data."}, {"field": "seen.uid", "type": "string", "description": "If the data was discovered within a connection, the connection uid should go here to give context to the data. If the conn field is provided, this will be automatically filled out."}, {"field": "seen.f", "type": "fa_file", "description": "(present if base/frameworks/intel/files.bro is loaded)"}, {"field": "seen.fuid", "type": "string", "description": "(present if base/frameworks/intel/files.bro is loaded)"}, {"field": "matched", "type": "Intel::TypeSet", "description": ""}, {"field": "sources", "type": "set", "description": "Sources which supplied data that resulted in this match."}, {"field": "fuid", "type": "string", "description": "(present if base/frameworks/intel/files.bro is loaded)"}, {"field": "file_mime_type", "type": "string", "description": "(present if base/frameworks/intel/files.bro is loaded)"}, {"field": "file_desc", "type": "string", "description": "(present if base/frameworks/intel/files.bro is loaded)"}], "file": "intel.log", "pattern": {"pattern": "%{NUMBER:ts}\\t%{NOTSPACE:uid}\\t%{IP:orig_h}\\t%{INT:orig_p}\\t%{IP:resp_h}\\t%{INT:resp_p}\\t%{GREEDYDATA:seen.indicator}\\t%{GREEDYDATA:seen.indicator_type}\\t%{IP:seen.host}\\t%{GREEDYDATA:seen.where}\\t%{GREEDYDATA:seen.node}\\t%{GREEDYDATA:seen.conn}\\t%{NOTSPACE:seen.uid}\\t%{GREEDYDATA:seen.f}\\t%{NOTSPACE:seen.fuid}\\t%{GREEDYDATA:matched}\\t%{GREEDYDATA:sources}\\t%{NOTSPACE:fuid}\\t%{GREEDYDATA:file_mime_type}\\t%{GREEDYDATA:file_desc}", "name": "BRO_INTEL"}, "log_type": "intel"}, {"description": "Bro notices", "url": "https://www.bro.org/sphinx/scripts/base/frameworks/notice/main.bro.html#type-Notice::Info", "fields": [{"field": "ts", "type": "time", "description": "An absolute time indicating when the notice occurred, defaults to the current network time."}, {"field": "uid", "type": "string", "description": "A connection UID which uniquely identifies the endpoints concerned with the notice."}, {"field": "id", "type": "conn_id", "description": "A connection 4-tuple identifying the endpoints concerned with the notice."}, {"field": "conn", "type": "connection", "description": "A shorthand way of giving the uid and id to a notice.  The reference to the actual connection will be deleted after applying the notice policy."}, {"field": "iconn", "type": "icmp_conn", "description": "A shorthand way of giving the uid and id to a notice.  The reference to the actual connection will be deleted after applying the notice policy."}, {"field": "f", "type": "fa_file", "description": "A file record if the notice is related to a file.  The reference to the actual fa_file record will be deleted after applying the notice policy."}, {"field": "fuid", "type": "string", "description": "A file unique ID if this notice is related to a file.  If the f field is provided, this will be automatically filled out."}, {"field": "file_mime_type", "type": "string", "description": "A mime type if the notice is related to a file.  If the f field is provided, this will be automatically filled out."}, {"field": "file_desc", "type": "string", "description": "Frequently files can be described to give a bit more context.  This field will typically be automatically filled out from an fa_file record.  For example, if a notice was related to a file over HTTP, the URL of the request would be shown."}, {"field": "proto", "type": "transport_proto", "description": "The transport protocol. Filled automatically when either conn, iconn or p is specified."}, {"field": "note", "type": "Notice::Type", "description": ""}, {"field": "msg", "type": "string", "description": "The human readable message for the notice."}, {"field": "sub", "type": "string", "description": "The human readable sub-message."}, {"field": "src", "type": "addr", "description": "Source address, if we dont have a conn_id."}, {"field": "dst", "type": "addr", "description": "Destination address."}, {"field": "p", "type": "port", "description": "Associated port, if we dont have a conn_id."}, {"field": "n", "type": "count", "description": "Associated count, or perhaps a status code."}, {"field": "src_peer", "type": "event_peer", "description": "Peer that raised this notice."}, {"field": "peer_descr", "type": "string", "description": "Textual description for the peer that raised this notice."}, {"field": "actions", "type": "Notice::ActionSet", "description": ""}, {"field": "email_body_sections", "type": "vector", "description": "By adding chunks of text into this element, other scripts can expand on notices that are being emailed.  The normal way to add text is to extend the vector by handling the Notice::notice event and modifying the notice in place."}, {"field": "email_delay_tokens", "type": "set", "description": "Adding a string token to this set will cause the notice frameworks built-in emailing functionality to delay sending the email until either the token has been removed or the email has been delayed for Notice::max_email_delay."}, {"field": "identifier", "type": "string", "description": "This field is to be provided when a notice is generated for the purpose of deduplicating notices.  The identifier string should be unique for a single instance of the notice.  This field should be filled out in almost all cases when generating notices to define when a notice is conceptually a duplicate of a previous notice."}, {"field": "suppress_for", "type": "interval", "description": "This field indicates the length of time that this unique notice should be suppressed."}, {"field": "dropped", "type": "bool", "description": "(present if base/frameworks/notice/actions/drop.bro is loaded)"}, {"field": "remote_location", "type": "geo_location", "description": "(present if base/frameworks/notice/actions/add-geodata.bro is loaded)"}], "file": "notice.log", "pattern": {"pattern": "%{NUMBER:ts}\\t%{NOTSPACE:uid}\\t%{IP:orig_h}\\t%{INT:orig_p}\\t%{IP:resp_h}\\t%{INT:resp_p}\\t%{GREEDYDATA:conn}\\t%{GREEDYDATA:iconn}\\t%{GREEDYDATA:f}\\t%{NOTSPACE:fuid}\\t%{GREEDYDATA:file_mime_type}\\t%{GREEDYDATA:file_desc}\\t%{WORD:proto}\\t%{GREEDYDATA:note}\\t%{GREEDYDATA:msg}\\t%{GREEDYDATA:sub}\\t%{IP:src}\\t%{IP:dst}\\t%{INT:p}\\t%{INT:n}\\t%{GREEDYDATA:src_peer}\\t%{GREEDYDATA:peer_descr}\\t%{GREEDYDATA:actions}\\t%{GREEDYDATA:email_body_sections}\\t%{GREEDYDATA:email_delay_tokens}\\t%{GREEDYDATA:identifier}\\t%{GREEDYDATA:suppress_for}\\t%{GREEDYDATA:dropped}\\t%{GREEDYDATA:remote_location}", "name": "BRO_NOTICE"}, "log_type": "notice"}, {"fields": [], "log_type": "notice_alarm", "file": "notice_alarm.log", "description": "The alarm stream"}, {"description": "Signature matches", "url": "https://www.bro.org/sphinx/scripts/base/frameworks/signatures/main.bro.html#type-Signatures::Info", "fields": [{"field": "ts", "type": "time", "description": "The network time at which a signature matching type of event to be logged has occurred."}, {"field": "uid", "type": "string", "description": "A unique identifier of the connection which triggered the signature match event."}, {"field": "src_addr", "type": "addr", "description": "The host which triggered the signature match event."}, {"field": "src_port", "type": "port", "description": "The host port on which the signature-matching activity occurred."}, {"field": "dst_addr", "type": "addr", "description": "The destination host which was sent the payload that triggered the signature match."}, {"field": "dst_port", "type": "port", "description": "The destination host port which was sent the payload that triggered the signature match."}, {"field": "note", "type": "Notice::Type", "description": ""}, {"field": "sig_id", "type": "string", "description": "The name of the signature that matched."}, {"field": "event_msg", "type": "string", "description": "A more descriptive message of the signature-matching event."}, {"field": "sub_msg", "type": "string", "description": "Extracted payload data or extra message."}, {"field": "sig_count", "type": "count", "description": "Number of sigs, usually from summary count."}, {"field": "host_count", "type": "count", "description": "Number of hosts, from a summary count."}], "file": "signatures.log", "pattern": {"pattern": "%{NUMBER:ts}\\t%{NOTSPACE:uid}\\t%{IP:src_addr}\\t%{INT:src_port}\\t%{IP:dst_addr}\\t%{INT:dst_port}\\t%{GREEDYDATA:note}\\t%{GREEDYDATA:sig_id}\\t%{GREEDYDATA:event_msg}\\t%{GREEDYDATA:sub_msg}\\t%{INT:sig_count}\\t%{INT:host_count}", "name": "BRO_SIGNATURES"}, "log_type": "signatures"}, {"description": "Traceroute detection", "url": "https://www.bro.org/sphinx/scripts/policy/misc/detect-traceroute/main.bro.html#type-Traceroute::Info", "fields": [{"field": "ts", "type": "time", "description": "Timestamp"}, {"field": "src", "type": "addr", "description": "Address initiating the traceroute."}, {"field": "dst", "type": "addr", "description": "Destination address of the traceroute."}, {"field": "proto", "type": "string", "description": "Protocol used for the traceroute."}], "file": "traceroute.log", "pattern": {"pattern": "%{NUMBER:ts}\\t%{IP:src}\\t%{IP:dst}\\t%{GREEDYDATA:proto}", "name": "BRO_TRACEROUTE"}, "log_type": "traceroute"}, {"description": "SSL certificates", "url": "https://www.bro.org/sphinx/scripts/policy/protocols/ssl/known-certs.bro.html#type-Known::CertsInfo", "fields": [{"field": "ts", "type": "time", "description": "The timestamp when the certificate was detected."}, {"field": "host", "type": "addr", "description": "The address that offered the certificate."}, {"field": "port_num", "type": "port", "description": "If the certificate was handed out by a server, this is the port that the server was listening on."}, {"field": "subject", "type": "string", "description": "Certificate subject."}, {"field": "issuer_subject", "type": "string", "description": "Certificate issuer subject."}, {"field": "serial", "type": "string", "description": "Serial number for the certificate."}], "file": "known_certs.log", "pattern": {"pattern": "%{NUMBER:ts}\\t%{IP:host}\\t%{INT:port_num}\\t%{GREEDYDATA:subject}\\t%{GREEDYDATA:issuer_subject}\\t%{GREEDYDATA:serial}", "name": "BRO_KNOWN_CERTS"}, "log_type": "known_certs"}, {"description": "MAC addresses of devices on the\nnetwork", "url": "https://www.bro.org/sphinx/scripts/policy/misc/known-devices.bro.html#type-Known::DevicesInfo", "fields": [{"field": "ts", "type": "time", "description": "The timestamp at which the host was detected."}, {"field": "mac", "type": "string", "description": "The MAC address that was detected."}, {"field": "dhcp_host_name", "type": "string", "description": "(present if policy/protocols/dhcp/known-devices-and-hostnames.bro is loaded)"}], "file": "known_devices.log", "pattern": {"pattern": "%{NUMBER:ts}\\t%{GREEDYDATA:mac}\\t%{GREEDYDATA:dhcp_host_name}", "name": "BRO_KNOWN_DEVICES"}, "log_type": "known_devices"}, {"description": "Hosts that have completed TCP\nhandshakes", "url": "https://www.bro.org/sphinx/scripts/policy/protocols/conn/known-hosts.bro.html#type-Known::HostsInfo", "fields": [{"field": "ts", "type": "time", "description": "The timestamp at which the host was detected."}, {"field": "host", "type": "addr", "description": "The address that was detected originating or responding to a TCP connection."}], "file": "known_hosts.log", "pattern": {"pattern": "%{NUMBER:ts}\\t%{IP:host}", "name": "BRO_KNOWN_HOSTS"}, "log_type": "known_hosts"}, {"description": "Modbus masters and slaves", "url": "https://www.bro.org/sphinx/scripts/policy/protocols/modbus/known-masters-slaves.bro.html#type-Known::ModbusInfo", "fields": [{"field": "ts", "type": "time", "description": "The time the device was discovered."}, {"field": "host", "type": "addr", "description": "The IP address of the host."}, {"field": "device_type", "type": "Known::ModbusDeviceType", "description": ""}], "file": "known_modbus.log", "pattern": {"pattern": "%{NUMBER:ts}\\t%{IP:host}\\t%{GREEDYDATA:device_type}", "name": "BRO_KNOWN_MODBUS"}, "log_type": "known_modbus"}, {"description": "Services running on hosts", "url": "https://www.bro.org/sphinx/scripts/policy/protocols/conn/known-services.bro.html#type-Known::ServicesInfo", "fields": [{"field": "ts", "type": "time", "description": "The time at which the service was detected."}, {"field": "host", "type": "addr", "description": "The host address on which the service is running."}, {"field": "port_num", "type": "port", "description": "The port number on which the service is running."}, {"field": "port_proto", "type": "transport_proto", "description": "The transport-layer protocol which the service uses."}, {"field": "service", "type": "set", "description": "A set of protocols that match the services connection payloads."}], "file": "known_services.log", "pattern": {"pattern": "%{NUMBER:ts}\\t%{IP:host}\\t%{INT:port_num}\\t%{WORD:port_proto}\\t%{GREEDYDATA:service}", "name": "BRO_KNOWN_SERVICES"}, "log_type": "known_services"}, {"description": "Software being used on the network", "url": "https://www.bro.org/sphinx/scripts/base/frameworks/software/main.bro.html#type-Software::Info", "fields": [{"field": "ts", "type": "time", "description": "The time at which the software was detected."}, {"field": "host", "type": "addr", "description": "The IP address detected running the software."}, {"field": "host_p", "type": "port", "description": "The port on which the software is running. Only sensible for server software."}, {"field": "software_type", "type": "Software::Type", "description": ""}, {"field": "name", "type": "string", "description": "Name of the software (e.g. Apache)."}, {"field": "version.major", "type": "count", "description": "Major version number."}, {"field": "version.minor", "type": "count", "description": "Minor version number."}, {"field": "version.minor2", "type": "count", "description": "Minor subversion number."}, {"field": "version.minor3", "type": "count", "description": "Minor updates number."}, {"field": "version.addl", "type": "string", "description": "Additional version string (e.g. beta42)."}, {"field": "unparsed_version", "type": "string", "description": "The full unparsed version string found because the version parsing doesnt always work reliably in all cases and this acts as a fallback in the logs."}, {"field": "force_log", "type": "bool", "description": "This can indicate that this software being detected should definitely be sent onward to the logging framework.  By default, only software that is interesting due to a change in version or it being currently unknown is sent to the logging framework.  This can be set to T to force the record to be sent to the logging framework if some amount of this tracking needs to happen in a specific way to the software."}, {"field": "url", "type": "string", "description": "(present if policy/protocols/http/detect-webapps.bro is loaded)"}], "file": "software.log", "pattern": {"pattern": "%{NUMBER:ts}\\t%{IP:host}\\t%{INT:host_p}\\t%{GREEDYDATA:software_type}\\t%{GREEDYDATA:name}\\t%{INT:version.major}\\t%{INT:version.minor}\\t%{INT:version.minor2}\\t%{INT:version.minor3}\\t%{GREEDYDATA:version.addl}\\t%{GREEDYDATA:unparsed_version}\\t%{GREEDYDATA:force_log}\\t%{GREEDYDATA:url}", "name": "BRO_SOFTWARE"}, "log_type": "software"}, {"description": "Alerts received from Barnyard2", "url": "https://www.bro.org/sphinx/scripts/policy/integration/barnyard2/main.bro.html#type-Barnyard2::Info", "fields": [{"field": "ts", "type": "time", "description": ""}, {"field": "pid", "type": "Barnyard2::PacketID", "description": ""}, {"field": "alert", "type": "Barnyard2::AlertData", "description": ""}], "file": "barnyard2.log", "pattern": {"pattern": "%{NUMBER:ts}\\t%{GREEDYDATA:pid}\\t%{GREEDYDATA:alert}", "name": "BRO_BARNYARD2"}, "log_type": "barnyard2"}, {"description": "Dynamic protocol detection failures", "url": "https://www.bro.org/sphinx/scripts/base/frameworks/dpd/main.bro.html#type-DPD::Info", "fields": [{"field": "ts", "type": "time", "description": "Timestamp for when protocol analysis failed."}, {"field": "uid", "type": "string", "description": "Connection unique ID."}, {"field": "id", "type": "conn_id", "description": "Connection ID containing the 4-tuple which identifies endpoints."}, {"field": "proto", "type": "transport_proto", "description": "Transport protocol for the violation."}, {"field": "analyzer", "type": "string", "description": "The analyzer that generated the violation."}, {"field": "failure_reason", "type": "string", "description": "The textual reason for the analysis failure."}, {"field": "disabled_aids", "type": "set", "description": "Disabled analyzer IDs.  This is only for internal tracking so as to not attempt to disable analyzers multiple times."}, {"field": "packet_segment", "type": "string", "description": "(present if policy/frameworks/dpd/packet-segment-logging.bro is loaded)"}], "file": "dpd.log", "pattern": {"pattern": "%{NUMBER:ts}\\t%{NOTSPACE:uid}\\t%{IP:orig_h}\\t%{INT:orig_p}\\t%{IP:resp_h}\\t%{INT:resp_p}\\t%{WORD:proto}\\t%{GREEDYDATA:analyzer}\\t%{GREEDYDATA:failure_reason}\\t%{GREEDYDATA:disabled_aids}\\t%{GREEDYDATA:packet_segment}", "name": "BRO_DPD"}, "log_type": "dpd"}, {"description": "Interprets Snort\u2019s unified output", "url": "https://www.bro.org/sphinx/scripts/base/files/unified2/main.bro.html#type-Unified2::Info", "fields": [{"field": "ts", "type": "time", "description": "Timestamp attached to the alert."}, {"field": "id.src_ip", "type": "addr", "description": ""}, {"field": "id.src_p", "type": "port", "description": ""}, {"field": "id.dst_ip", "type": "addr", "description": ""}, {"field": "id.dst_p", "type": "port", "description": ""}, {"field": "sensor_id", "type": "count", "description": "Sensor that originated this event."}, {"field": "signature_id", "type": "count", "description": "Sig id for this generator."}, {"field": "signature", "type": "string", "description": "A string representation of the signature_id field if a sid_msg.map file was loaded."}, {"field": "generator_id", "type": "count", "description": "Which generator generated the alert?"}, {"field": "generator", "type": "string", "description": "A string representation of the generator_id field if a gen_msg.map file was loaded."}, {"field": "signature_revision", "type": "count", "description": "Sig revision for this id."}, {"field": "classification_id", "type": "count", "description": "Event classification."}, {"field": "classification", "type": "string", "description": "Descriptive classification string."}, {"field": "priority_id", "type": "count", "description": "Event priority."}, {"field": "event_id", "type": "count", "description": "Event ID."}, {"field": "packet", "type": "string", "description": "Some of the packet data."}], "file": "unified2.log", "pattern": {"pattern": "%{NUMBER:ts}\\t%{IP:id.src_ip}\\t%{INT:id.src_p}\\t%{IP:id.dst_ip}\\t%{INT:id.dst_p}\\t%{INT:sensor_id}\\t%{INT:signature_id}\\t%{GREEDYDATA:signature}\\t%{INT:generator_id}\\t%{GREEDYDATA:generator}\\t%{INT:signature_revision}\\t%{INT:classification_id}\\t%{GREEDYDATA:classification}\\t%{INT:priority_id}\\t%{INT:event_id}\\t%{GREEDYDATA:packet}", "name": "BRO_UNIFIED2"}, "log_type": "unified2"}, {"description": "Unexpected network-level activity", "url": "https://www.bro.org/sphinx/scripts/base/frameworks/notice/weird.bro.html#type-Weird::Info", "fields": [{"field": "ts", "type": "time", "description": "The time when the weird occurred."}, {"field": "uid", "type": "string", "description": "If a connection is associated with this weird, this will be the connections unique ID."}, {"field": "id", "type": "conn_id", "description": "conn_id for the optional connection."}, {"field": "conn", "type": "connection", "description": "A shorthand way of giving the uid and id to a weird."}, {"field": "name", "type": "string", "description": "The name of the weird that occurred."}, {"field": "addl", "type": "string", "description": "Additional information accompanying the weird if any."}, {"field": "notice", "type": "bool", "description": "Indicate if this weird was also turned into a notice."}, {"field": "peer", "type": "string", "description": "The peer that originated this weird.  This is helpful in cluster deployments if a particular cluster node is having trouble to help identify which node is having trouble."}, {"field": "identifier", "type": "string", "description": "This field is to be provided when a weird is generated for the purpose of deduplicating weirds. The identifier string should be unique for a single instance of the weird. This field is used to define when a weird is conceptually a duplicate of a previous weird."}], "file": "weird.log", "pattern": {"pattern": "%{NUMBER:ts}\\t%{NOTSPACE:uid}\\t%{IP:orig_h}\\t%{INT:orig_p}\\t%{IP:resp_h}\\t%{INT:resp_p}\\t%{GREEDYDATA:conn}\\t%{GREEDYDATA:name}\\t%{GREEDYDATA:addl}\\t%{GREEDYDATA:notice}\\t%{GREEDYDATA:peer}\\t%{GREEDYDATA:identifier}", "name": "BRO_WEIRD"}, "log_type": "weird"}, {"description": "Packet loss rate", "url": "https://www.bro.org/sphinx/scripts/policy/misc/capture-loss.bro.html#type-CaptureLoss::Info", "fields": [{"field": "ts", "type": "time", "description": "Timestamp for when the measurement occurred."}, {"field": "ts_delta", "type": "interval", "description": "The time delay between this measurement and the last."}, {"field": "peer", "type": "string", "description": "In the event that there are multiple Bro instances logging to the same host, this distinguishes each peer with its individual name."}, {"field": "gaps", "type": "count", "description": "Number of missed ACKs from the previous measurement interval."}, {"field": "acks", "type": "count", "description": "Total number of ACKs seen in the previous measurement interval."}, {"field": "percent_lost", "type": "double", "description": "Percentage of ACKs seen where the data being ACKed wasnt seen."}], "file": "capture_loss.log", "pattern": {"pattern": "%{NUMBER:ts}\\t%{GREEDYDATA:ts_delta}\\t%{GREEDYDATA:peer}\\t%{INT:gaps}\\t%{INT:acks}\\t%{GREEDYDATA:percent_lost}", "name": "BRO_CAPTURE_LOSS"}, "log_type": "capture_loss"}, {"description": "Bro cluster messages", "url": "https://www.bro.org/sphinx/scripts/base/frameworks/cluster/main.bro.html#type-Cluster::Info", "fields": [{"field": "ts", "type": "time", "description": "The time at which a cluster message was generated."}, {"field": "message", "type": "string", "description": "A message indicating information about the clusters operation."}], "file": "cluster.log", "pattern": {"pattern": "%{NUMBER:ts}\\t%{GREEDYDATA:message}", "name": "BRO_CLUSTER"}, "log_type": "cluster"}, {"description": "Communication events between Bro or\nBroccoli instances", "url": "https://www.bro.org/sphinx/scripts/base/frameworks/communication/main.bro.html#type-Communication::Info", "fields": [{"field": "ts", "type": "time", "description": "The network time at which a communication event occurred."}, {"field": "peer", "type": "string", "description": "The peer name (if any) with which a communication event is concerned."}, {"field": "src_name", "type": "string", "description": "Where the communication event message originated from, that is, either from the scripting layer or inside the Bro process."}, {"field": "connected_peer_desc", "type": "string", "description": "Todo"}, {"field": "connected_peer_addr", "type": "addr", "description": "Todo"}, {"field": "connected_peer_port", "type": "port", "description": "Todo"}, {"field": "level", "type": "string", "description": "The severity of the communication event message."}, {"field": "message", "type": "string", "description": "A message describing the communication event between Bro or Broccoli instances."}], "file": "communication.log", "pattern": {"pattern": "%{NUMBER:ts}\\t%{GREEDYDATA:peer}\\t%{GREEDYDATA:src_name}\\t%{GREEDYDATA:connected_peer_desc}\\t%{IP:connected_peer_addr}\\t%{INT:connected_peer_port}\\t%{GREEDYDATA:level}\\t%{GREEDYDATA:message}", "name": "BRO_COMMUNICATION"}, "log_type": "communication"}, {"description": "Shows all scripts loaded by Bro", "url": "https://www.bro.org/sphinx/scripts/policy/misc/loaded-scripts.bro.html#type-LoadedScripts::Info", "fields": [{"field": "name", "type": "string", "description": "Name of the script loaded potentially with spaces included before the file name to indicate load depth.  The convention is two spaces per level of depth."}], "file": "loaded_scripts.log", "pattern": {"pattern": "%{GREEDYDATA:name}", "name": "BRO_LOADED_SCRIPTS"}, "log_type": "loaded_scripts"}, {"description": "List packet filters that were applied", "url": "https://www.bro.org/sphinx/scripts/base/frameworks/packet-filter/main.bro.html#type-PacketFilter::Info", "fields": [{"field": "ts", "type": "time", "description": "The time at which the packet filter installation attempt was made."}, {"field": "node", "type": "string", "description": "This is a string representation of the node that applied this packet filter.  Its mostly useful in the context of dynamically changing filters on clusters."}, {"field": "filter", "type": "string", "description": "The packet filter that is being set."}, {"field": "init", "type": "bool", "description": "Indicate if this is the filter set during initialization."}, {"field": "success", "type": "bool", "description": "Indicate if the filter was applied successfully."}], "file": "packet_filter.log", "pattern": {"pattern": "%{NUMBER:ts}\\t%{GREEDYDATA:node}\\t%{GREEDYDATA:filter}\\t%{GREEDYDATA:init}\\t%{GREEDYDATA:success}", "name": "BRO_PACKET_FILTER"}, "log_type": "packet_filter"}, {"fields": [], "log_type": "prof", "file": "prof.log", "description": "Profiling statistics (to create this\nlog, load policy/misc/profiling.bro)"}, {"description": "Internal error/warning/info messages", "url": "https://www.bro.org/sphinx/scripts/base/frameworks/reporter/main.bro.html#type-Reporter::Info", "fields": [{"field": "ts", "type": "time", "description": "The network time at which the reporter event was generated."}, {"field": "level", "type": "Reporter::Level", "description": ""}, {"field": "message", "type": "string", "description": "An info/warning/error message that could have either been generated from the internal Bro core or at the scripting-layer."}, {"field": "location", "type": "string", "description": "This is the location in a Bro script where the message originated. Not all reporter messages will have locations in them though."}], "file": "reporter.log", "pattern": {"pattern": "%{NUMBER:ts}\\t%{GREEDYDATA:level}\\t%{GREEDYDATA:message}\\t%{GREEDYDATA:location}", "name": "BRO_REPORTER"}, "log_type": "reporter"}, {"description": "Memory/event/packet/lag statistics", "url": "https://www.bro.org/sphinx/scripts/policy/misc/stats.bro.html#type-Stats::Info", "fields": [{"field": "ts", "type": "time", "description": "Timestamp for the measurement."}, {"field": "peer", "type": "string", "description": "Peer that generated this log.  Mostly for clusters."}, {"field": "mem", "type": "count", "description": "Amount of memory currently in use in MB."}, {"field": "pkts_proc", "type": "count", "description": "Number of packets processed since the last stats interval."}, {"field": "bytes_recv", "type": "count", "description": "Number of bytes received since the last stats interval if reading live traffic."}, {"field": "pkts_dropped", "type": "count", "description": "Number of packets dropped since the last stats interval if reading live traffic."}, {"field": "pkts_link", "type": "count", "description": "Number of packets seen on the link since the last stats interval if reading live traffic."}, {"field": "pkt_lag", "type": "interval", "description": "Lag between the wall clock and packet timestamps if reading live traffic."}, {"field": "events_proc", "type": "count", "description": "Number of events processed since the last stats interval."}, {"field": "events_queued", "type": "count", "description": "Number of events that have been queued since the last stats interval."}, {"field": "active_tcp_conns", "type": "count", "description": "TCP connections currently in memory."}, {"field": "active_udp_conns", "type": "count", "description": "UDP connections currently in memory."}, {"field": "active_icmp_conns", "type": "count", "description": "ICMP connections currently in memory."}, {"field": "tcp_conns", "type": "count", "description": "TCP connections seen since last stats interval."}, {"field": "udp_conns", "type": "count", "description": "UDP connections seen since last stats interval."}, {"field": "icmp_conns", "type": "count", "description": "ICMP connections seen since last stats interval."}, {"field": "timers", "type": "count", "description": "Number of timers scheduled since last stats interval."}, {"field": "active_timers", "type": "count", "description": "Current number of scheduled timers."}, {"field": "files", "type": "count", "description": "Number of files seen since last stats interval."}, {"field": "active_files", "type": "count", "description": "Current number of files actively being seen."}, {"field": "dns_requests", "type": "count", "description": "Number of DNS requests seen since last stats interval."}, {"field": "active_dns_requests", "type": "count", "description": "Current number of DNS requests awaiting a reply."}, {"field": "reassem_tcp_size", "type": "count", "description": "Current size of TCP data in reassembly."}, {"field": "reassem_file_size", "type": "count", "description": "Current size of File data in reassembly."}, {"field": "reassem_frag_size", "type": "count", "description": "Current size of packet fragment data in reassembly."}, {"field": "reassem_unknown_size", "type": "count", "description": "Current size of unknown data in reassembly (this is only PIA buffer right now)."}], "file": "stats.log", "pattern": {"pattern": "%{NUMBER:ts}\\t%{GREEDYDATA:peer}\\t%{INT:mem}\\t%{INT:pkts_proc}\\t%{INT:bytes_recv}\\t%{INT:pkts_dropped}\\t%{INT:pkts_link}\\t%{GREEDYDATA:pkt_lag}\\t%{INT:events_proc}\\t%{INT:events_queued}\\t%{INT:active_tcp_conns}\\t%{INT:active_udp_conns}\\t%{INT:active_icmp_conns}\\t%{INT:tcp_conns}\\t%{INT:udp_conns}\\t%{INT:icmp_conns}\\t%{INT:timers}\\t%{INT:active_timers}\\t%{INT:files}\\t%{INT:active_files}\\t%{INT:dns_requests}\\t%{INT:active_dns_requests}\\t%{INT:reassem_tcp_size}\\t%{INT:reassem_file_size}\\t%{INT:reassem_frag_size}\\t%{INT:reassem_unknown_size}", "name": "BRO_STATS"}, "log_type": "stats"}, {"fields": [], "log_type": "stderr", "file": "stderr.log", "description": "Captures standard error when Bro is\nstarted from BroControl"}, {"fields": [], "log_type": "stdout", "file": "stdout.log", "description": "Captures standard output when Bro is\nstarted from BroControl"}]}