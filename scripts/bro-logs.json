{"logs": [{"description": "TCP/UDP/ICMP connections", "url": "https://www.bro.org/sphinx/scripts/base/protocols/conn/main.bro.html#type-Conn::Info", "fields": [{"field": "ts", "type": "time", "description": "This is the time of the first packet."}, {"field": "uid", "type": "string", "description": "A unique identifier of the connection."}, {"field": "id", "type": "conn_id", "description": "The connection\u2019s 4-tuple of endpoint addresses/ports."}, {"field": "proto", "type": "transport_proto", "description": "The transport layer protocol of the connection."}, {"field": "service", "type": "string", "description": "An identification of an application protocol being sent over\nthe connection."}, {"field": "duration", "type": "interval", "description": "How long the connection lasted.  For 3-way or 4-way connection\ntear-downs, this will not include the final ACK."}, {"field": "orig_bytes", "type": "count", "description": "The number of payload bytes the originator sent. For TCP\nthis is taken from sequence numbers and might be inaccurate\n(e.g., due to large connections)."}, {"field": "resp_bytes", "type": "count", "description": "The number of payload bytes the responder sent. See\norig_bytes."}, {"field": "conn_state", "type": "string", "description": ""}, {"field": "local_orig", "type": "bool", "description": "If the connection is originated locally, this value will be T.\nIf it was originated remotely it will be F.  In the case that\nthe Site::local_nets variable is undefined, this\nfield will be left empty at all times."}, {"field": "local_resp", "type": "bool", "description": "If the connection is responded to locally, this value will be T.\nIf it was responded to remotely it will be F.  In the case that\nthe Site::local_nets variable is undefined, this\nfield will be left empty at all times."}, {"field": "missed_bytes", "type": "count", "description": "Indicates the number of bytes missed in content gaps, which\nis representative of packet loss.  A value other than zero\nwill normally cause protocol analysis to fail but some\nanalysis may have been completed prior to the packet loss."}, {"field": "history", "type": "string", "description": "Records the state history of connections as a string of\nletters.  The meaning of those letters is:"}, {"field": "orig_pkts", "type": "count", "description": "Number of packets that the originator sent.\nOnly set if use_conn_size_analyzer = T."}, {"field": "orig_ip_bytes", "type": "count", "description": "Number of IP level bytes that the originator sent (as seen on\nthe wire, taken from the IP total_length header field).\nOnly set if use_conn_size_analyzer = T."}, {"field": "resp_pkts", "type": "count", "description": "Number of packets that the responder sent.\nOnly set if use_conn_size_analyzer = T."}, {"field": "resp_ip_bytes", "type": "count", "description": "Number of IP level bytes that the responder sent (as seen on\nthe wire, taken from the IP total_length header field).\nOnly set if use_conn_size_analyzer = T."}, {"field": "tunnel_parents", "type": "set", "description": "If this connection was over a tunnel, indicate the\nuid values for any encapsulating parent connections\nused over the lifetime of this inner connection."}, {"field": "orig_l2_addr", "type": "string", "description": "(present if policy/protocols/conn/mac-logging.bro is loaded)"}, {"field": "resp_l2_addr", "type": "string", "description": "(present if policy/protocols/conn/mac-logging.bro is loaded)"}, {"field": "vlan", "type": "int", "description": "(present if policy/protocols/conn/vlan-logging.bro is loaded)"}, {"field": "inner_vlan", "type": "int", "description": "(present if policy/protocols/conn/vlan-logging.bro is loaded)"}], "file": "conn.log", "pattern": {"pattern": "%{NUMBER:ts}\\t%{NOTSPACE:uid}\\t%{IP:orig_h}\\t%{INT:orig_p}\\t%{IP:resp_h}\\t%{INT:resp_p}\\t%{WORD:proto}\\t%{GREEDYDATA:service}\\t%{GREEDYDATA:duration}\\t%{INT:orig_bytes}\\t%{INT:resp_bytes}\\t%{GREEDYDATA:conn_state}\\t%{GREEDYDATA:local_orig}\\t%{GREEDYDATA:local_resp}\\t%{INT:missed_bytes}\\t%{GREEDYDATA:history}\\t%{INT:orig_pkts}\\t%{INT:orig_ip_bytes}\\t%{INT:resp_pkts}\\t%{INT:resp_ip_bytes}\\t%{GREEDYDATA:tunnel_parents}\\t%{GREEDYDATA:orig_l2_addr}\\t%{GREEDYDATA:resp_l2_addr}\\t%{INT:vlan}\\t%{INT:inner_vlan}", "name": "BRO_CONN"}, "log_type": "conn"}, {"description": "Distributed Computing Environment/RPC", "url": "https://www.bro.org/sphinx/scripts/base/protocols/dce-rpc/main.bro.html#type-DCE_RPC::Info", "fields": [{"field": "ts", "type": "time", "description": "Timestamp for when the event happened."}, {"field": "uid", "type": "string", "description": "Unique ID for the connection."}, {"field": "id", "type": "conn_id", "description": "The connection\u2019s 4-tuple of endpoint addresses/ports."}, {"field": "rtt", "type": "interval", "description": "Round trip time from the request to the response.\nIf either the request or response wasn\u2019t seen,\nthis will be null."}, {"field": "named_pipe", "type": "string", "description": "Remote pipe name."}, {"field": "endpoint", "type": "string", "description": "Endpoint name looked up from the uuid."}, {"field": "operation", "type": "string", "description": "Operation seen in the call."}], "file": "dce_rpc.log", "pattern": {"pattern": "%{NUMBER:ts}\\t%{NOTSPACE:uid}\\t%{IP:orig_h}\\t%{INT:orig_p}\\t%{IP:resp_h}\\t%{INT:resp_p}\\t%{GREEDYDATA:rtt}\\t%{GREEDYDATA:named_pipe}\\t%{GREEDYDATA:endpoint}\\t%{GREEDYDATA:operation}", "name": "BRO_DCE_RPC"}, "log_type": "dce_rpc"}, {"description": "DHCP leases", "url": "https://www.bro.org/sphinx/scripts/base/protocols/dhcp/main.bro.html#type-DHCP::Info", "fields": [{"field": "ts", "type": "time", "description": "The earliest time at which a DHCP message over the\nassociated connection is observed."}, {"field": "uid", "type": "string", "description": "A unique identifier of the connection over which DHCP is\noccurring."}, {"field": "id", "type": "conn_id", "description": "The connection\u2019s 4-tuple of endpoint addresses/ports."}, {"field": "mac", "type": "string", "description": "Client\u2019s hardware address."}, {"field": "assigned_ip", "type": "addr", "description": "Client\u2019s actual assigned IP address."}, {"field": "lease_time", "type": "interval", "description": "IP address lease interval."}, {"field": "trans_id", "type": "count", "description": "A random number chosen by the client for this transaction."}], "file": "dhcp.log", "pattern": {"pattern": "%{NUMBER:ts}\\t%{NOTSPACE:uid}\\t%{IP:orig_h}\\t%{INT:orig_p}\\t%{IP:resp_h}\\t%{INT:resp_p}\\t%{GREEDYDATA:mac}\\t%{IP:assigned_ip}\\t%{GREEDYDATA:lease_time}\\t%{INT:trans_id}", "name": "BRO_DHCP"}, "log_type": "dhcp"}, {"description": "DNP3 requests and replies", "url": "https://www.bro.org/sphinx/scripts/base/protocols/dnp3/main.bro.html#type-DNP3::Info", "fields": [{"field": "ts", "type": "time", "description": "Time of the request."}, {"field": "uid", "type": "string", "description": "Unique identifier for the connection."}, {"field": "id", "type": "conn_id", "description": "Identifier for the connection."}, {"field": "fc_request", "type": "string", "description": "The name of the function message in the request."}, {"field": "fc_reply", "type": "string", "description": "The name of the function message in the reply."}, {"field": "iin", "type": "count", "description": "The response\u2019s \u201cinternal indication number\u201d."}], "file": "dnp3.log", "pattern": {"pattern": "%{NUMBER:ts}\\t%{NOTSPACE:uid}\\t%{IP:orig_h}\\t%{INT:orig_p}\\t%{IP:resp_h}\\t%{INT:resp_p}\\t%{GREEDYDATA:fc_request}\\t%{GREEDYDATA:fc_reply}\\t%{INT:iin}", "name": "BRO_DNP3"}, "log_type": "dnp3"}, {"description": "DNS activity", "url": "https://www.bro.org/sphinx/scripts/base/protocols/dns/main.bro.html#type-DNS::Info", "fields": [{"field": "ts", "type": "time", "description": "The earliest time at which a DNS protocol message over the\nassociated connection is observed."}, {"field": "uid", "type": "string", "description": "A unique identifier of the connection over which DNS messages\nare being transferred."}, {"field": "id", "type": "conn_id", "description": "The connection\u2019s 4-tuple of endpoint addresses/ports."}, {"field": "proto", "type": "transport_proto", "description": "The transport layer protocol of the connection."}, {"field": "trans_id", "type": "count", "description": "A 16-bit identifier assigned by the program that generated\nthe DNS query.  Also used in responses to match up replies to\noutstanding queries."}, {"field": "rtt", "type": "interval", "description": "Round trip time for the query and response. This indicates\nthe delay between when the request was seen until the\nanswer started."}, {"field": "query", "type": "string", "description": "The domain name that is the subject of the DNS query."}, {"field": "qclass", "type": "count", "description": "The QCLASS value specifying the class of the query."}, {"field": "qclass_name", "type": "string", "description": "A descriptive name for the class of the query."}, {"field": "qtype", "type": "count", "description": "A QTYPE value specifying the type of the query."}, {"field": "qtype_name", "type": "string", "description": "A descriptive name for the type of the query."}, {"field": "rcode", "type": "count", "description": "The response code value in DNS response messages."}, {"field": "rcode_name", "type": "string", "description": "A descriptive name for the response code value."}, {"field": "AA", "type": "bool", "description": "The Authoritative Answer bit for response messages specifies\nthat the responding name server is an authority for the\ndomain name in the question section."}, {"field": "TC", "type": "bool", "description": "The Truncation bit specifies that the message was truncated."}, {"field": "RD", "type": "bool", "description": "The Recursion Desired bit in a request message indicates that\nthe client wants recursive service for this query."}, {"field": "RA", "type": "bool", "description": "The Recursion Available bit in a response message indicates\nthat the name server supports recursive queries."}, {"field": "Z", "type": "count", "description": "A reserved field that is usually zero in\nqueries and responses."}, {"field": "answers", "type": "vector", "description": "The set of resource descriptions in the query answer."}, {"field": "TTLs", "type": "vector", "description": "The caching intervals of the associated RRs described by the\nanswers field."}, {"field": "rejected", "type": "bool", "description": "The DNS query was rejected by the server."}, {"field": "total_answers", "type": "count", "description": "The total number of resource records in a reply message\u2019s\nanswer section."}, {"field": "total_replies", "type": "count", "description": "The total number of resource records in a reply message\u2019s\nanswer, authority, and additional sections."}, {"field": "saw_query", "type": "bool", "description": "Whether the full DNS query has been seen."}, {"field": "saw_reply", "type": "bool", "description": "Whether the full DNS reply has been seen."}, {"field": "auth", "type": "set", "description": "(present if policy/protocols/dns/auth-addl.bro is loaded)"}, {"field": "addl", "type": "set", "description": "(present if policy/protocols/dns/auth-addl.bro is loaded)"}], "file": "dns.log", "pattern": {"pattern": "%{NUMBER:ts}\\t%{NOTSPACE:uid}\\t%{IP:orig_h}\\t%{INT:orig_p}\\t%{IP:resp_h}\\t%{INT:resp_p}\\t%{WORD:proto}\\t%{INT:trans_id}\\t%{GREEDYDATA:rtt}\\t%{GREEDYDATA:query}\\t%{INT:qclass}\\t%{GREEDYDATA:qclass_name}\\t%{INT:qtype}\\t%{GREEDYDATA:qtype_name}\\t%{INT:rcode}\\t%{GREEDYDATA:rcode_name}\\t%{GREEDYDATA:AA}\\t%{GREEDYDATA:TC}\\t%{GREEDYDATA:RD}\\t%{GREEDYDATA:RA}\\t%{INT:Z}\\t%{GREEDYDATA:answers}\\t%{GREEDYDATA:TTLs}\\t%{GREEDYDATA:rejected}\\t%{INT:total_answers}\\t%{INT:total_replies}\\t%{GREEDYDATA:saw_query}\\t%{GREEDYDATA:saw_reply}\\t%{GREEDYDATA:auth}\\t%{GREEDYDATA:addl}", "name": "BRO_DNS"}, "log_type": "dns"}, {"description": "FTP activity", "url": "https://www.bro.org/sphinx/scripts/base/protocols/ftp/info.bro.html#type-FTP::Info", "fields": [{"field": "ts", "type": "time", "description": "Time when the command was sent."}, {"field": "uid", "type": "string", "description": "Unique ID for the connection."}, {"field": "id", "type": "conn_id", "description": "The connection\u2019s 4-tuple of endpoint addresses/ports."}, {"field": "user", "type": "string", "description": "User name for the current FTP session."}, {"field": "password", "type": "string", "description": "Password for the current FTP session if captured."}, {"field": "command", "type": "string", "description": "Command given by the client."}, {"field": "arg", "type": "string", "description": "Argument for the command if one is given."}, {"field": "mime_type", "type": "string", "description": "Libmagic \u201csniffed\u201d file type if the command indicates a file\ntransfer."}, {"field": "file_size", "type": "count", "description": "Size of the file if the command indicates a file transfer."}, {"field": "reply_code", "type": "count", "description": "Reply code from the server in response to the command."}, {"field": "reply_msg", "type": "string", "description": "Reply message from the server in response to the command."}, {"field": "data_channel.passive", "type": "bool", "description": "Whether PASV mode is toggled for control channel."}, {"field": "data_channel.orig_h", "type": "addr", "description": "The host that will be initiating the data connection."}, {"field": "data_channel.resp_h", "type": "addr", "description": "The host that will be accepting the data connection."}, {"field": "data_channel.resp_p", "type": "port", "description": "The port at which the acceptor is listening for the data\nconnection."}, {"field": "cwd", "type": "string", "description": "Current working directory that this session is in.  By making\nthe default value \u2018.\u2019, we can indicate that unless something\nmore concrete is discovered that the existing but unknown\ndirectory is ok to use."}, {"field": "cmdarg.ts", "type": "time", "description": "Time when the command was sent."}, {"field": "cmdarg.cmd", "type": "string", "description": "Command."}, {"field": "cmdarg.arg", "type": "string", "description": "Argument for the command if one was given."}, {"field": "cmdarg.seq", "type": "count", "description": "Counter to track how many commands have been executed."}, {"field": "pending_commands", "type": "FTP::PendingCmds", "description": ""}, {"field": "passive", "type": "bool", "description": "Indicates if the session is in active or passive mode."}, {"field": "capture_password", "type": "bool", "description": "Determines if the password will be captured for this request."}, {"field": "fuid", "type": "string", "description": "(present if base/protocols/ftp/files.bro is loaded)"}, {"field": "last_auth_requested", "type": "string", "description": "(present if base/protocols/ftp/gridftp.bro is loaded)"}], "file": "ftp.log", "pattern": {"pattern": "%{NUMBER:ts}\\t%{NOTSPACE:uid}\\t%{IP:orig_h}\\t%{INT:orig_p}\\t%{IP:resp_h}\\t%{INT:resp_p}\\t%{GREEDYDATA:user}\\t%{GREEDYDATA:password}\\t%{GREEDYDATA:command}\\t%{GREEDYDATA:arg}\\t%{GREEDYDATA:mime_type}\\t%{INT:file_size}\\t%{INT:reply_code}\\t%{GREEDYDATA:reply_msg}\\t%{GREEDYDATA:data_channel.passive}\\t%{IP:data_channel.orig_h}\\t%{IP:data_channel.resp_h}\\t%{INT:data_channel.resp_p}\\t%{GREEDYDATA:cwd}\\t%{NUMBER:cmdarg.ts}\\t%{GREEDYDATA:cmdarg.cmd}\\t%{GREEDYDATA:cmdarg.arg}\\t%{INT:cmdarg.seq}\\t%{GREEDYDATA:pending_commands}\\t%{GREEDYDATA:passive}\\t%{GREEDYDATA:capture_password}\\t%{NOTSPACE:fuid}\\t%{GREEDYDATA:last_auth_requested}", "name": "BRO_FTP"}, "log_type": "ftp"}, {"description": "HTTP requests and replies", "url": "https://www.bro.org/sphinx/scripts/base/protocols/http/main.bro.html#type-HTTP::Info", "fields": [{"field": "ts", "type": "time", "description": "Timestamp for when the request happened."}, {"field": "uid", "type": "string", "description": "Unique ID for the connection."}, {"field": "id", "type": "conn_id", "description": "The connection\u2019s 4-tuple of endpoint addresses/ports."}, {"field": "trans_depth", "type": "count", "description": "Represents the pipelined depth into the connection of this\nrequest/response transaction."}, {"field": "method", "type": "string", "description": "Verb used in the HTTP request (GET, POST, HEAD, etc.)."}, {"field": "host", "type": "string", "description": "Value of the HOST header."}, {"field": "uri", "type": "string", "description": "URI used in the request."}, {"field": "referrer", "type": "string", "description": "Value of the \u201creferer\u201d header.  The comment is deliberately\nmisspelled like the standard declares, but the name used here\nis \u201creferrer\u201d spelled correctly."}, {"field": "version", "type": "string", "description": "Value of the version portion of the request."}, {"field": "user_agent", "type": "string", "description": "Value of the User-Agent header from the client."}, {"field": "request_body_len", "type": "count", "description": "Actual uncompressed content size of the data transferred from\nthe client."}, {"field": "response_body_len", "type": "count", "description": "Actual uncompressed content size of the data transferred from\nthe server."}, {"field": "status_code", "type": "count", "description": "Status code returned by the server."}, {"field": "status_msg", "type": "string", "description": "Status message returned by the server."}, {"field": "info_code", "type": "count", "description": "Last seen 1xx informational reply code returned by the server."}, {"field": "info_msg", "type": "string", "description": "Last seen 1xx informational reply message returned by the server."}, {"field": "tags", "type": "set", "description": "A set of indicators of various attributes discovered and\nrelated to a particular request/response pair."}, {"field": "username", "type": "string", "description": "Username if basic-auth is performed for the request."}, {"field": "password", "type": "string", "description": "Password if basic-auth is performed for the request."}, {"field": "capture_password", "type": "bool", "description": "Determines if the password will be captured for this request."}, {"field": "proxied", "type": "set", "description": "All of the headers that may indicate if the request was proxied."}, {"field": "range_request", "type": "bool", "description": "Indicates if this request can assume 206 partial content in\nresponse."}, {"field": "orig_fuids", "type": "vector", "description": "(present if base/protocols/http/entities.bro is loaded)"}, {"field": "orig_filenames", "type": "vector", "description": "(present if base/protocols/http/entities.bro is loaded)"}, {"field": "orig_mime_types", "type": "vector", "description": "(present if base/protocols/http/entities.bro is loaded)"}, {"field": "resp_fuids", "type": "vector", "description": "(present if base/protocols/http/entities.bro is loaded)"}, {"field": "resp_filenames", "type": "vector", "description": "(present if base/protocols/http/entities.bro is loaded)"}, {"field": "resp_mime_types", "type": "vector", "description": "(present if base/protocols/http/entities.bro is loaded)"}, {"field": "current_entity.filename", "type": "string", "description": "Filename for the entity if discovered from a header."}, {"field": "orig_mime_depth", "type": "count", "description": "(present if base/protocols/http/entities.bro is loaded)"}, {"field": "resp_mime_depth", "type": "count", "description": "(present if base/protocols/http/entities.bro is loaded)"}, {"field": "client_header_names", "type": "vector", "description": "(present if policy/protocols/http/header-names.bro is loaded)"}, {"field": "server_header_names", "type": "vector", "description": "(present if policy/protocols/http/header-names.bro is loaded)"}, {"field": "omniture", "type": "bool", "description": "(present if policy/protocols/http/software-browser-plugins.bro is loaded)"}, {"field": "flash_version", "type": "string", "description": "(present if policy/protocols/http/software-browser-plugins.bro is loaded)"}, {"field": "cookie_vars", "type": "vector", "description": "(present if policy/protocols/http/var-extraction-cookies.bro is loaded)"}, {"field": "uri_vars", "type": "vector", "description": "(present if policy/protocols/http/var-extraction-uri.bro is loaded)"}], "file": "http.log", "pattern": {"pattern": "%{NUMBER:ts}\\t%{NOTSPACE:uid}\\t%{IP:orig_h}\\t%{INT:orig_p}\\t%{IP:resp_h}\\t%{INT:resp_p}\\t%{INT:trans_depth}\\t%{GREEDYDATA:method}\\t%{GREEDYDATA:host}\\t%{GREEDYDATA:uri}\\t%{GREEDYDATA:referrer}\\t%{GREEDYDATA:version}\\t%{GREEDYDATA:user_agent}\\t%{INT:request_body_len}\\t%{INT:response_body_len}\\t%{INT:status_code}\\t%{GREEDYDATA:status_msg}\\t%{INT:info_code}\\t%{GREEDYDATA:info_msg}\\t%{GREEDYDATA:tags}\\t%{GREEDYDATA:username}\\t%{GREEDYDATA:password}\\t%{GREEDYDATA:capture_password}\\t%{GREEDYDATA:proxied}\\t%{GREEDYDATA:range_request}\\t%{NOTSPACE:orig_fuids}\\t%{GREEDYDATA:orig_filenames}\\t%{GREEDYDATA:orig_mime_types}\\t%{NOTSPACE:resp_fuids}\\t%{GREEDYDATA:resp_filenames}\\t%{GREEDYDATA:resp_mime_types}\\t%{GREEDYDATA:current_entity.filename}\\t%{INT:orig_mime_depth}\\t%{INT:resp_mime_depth}\\t%{GREEDYDATA:client_header_names}\\t%{GREEDYDATA:server_header_names}\\t%{GREEDYDATA:omniture}\\t%{GREEDYDATA:flash_version}\\t%{GREEDYDATA:cookie_vars}\\t%{GREEDYDATA:uri_vars}", "name": "BRO_HTTP"}, "log_type": "http"}, {"description": "IRC commands and responses", "url": "https://www.bro.org/sphinx/scripts/base/protocols/irc/main.bro.html#type-IRC::Info", "fields": [{"field": "ts", "type": "time", "description": "Timestamp when the command was seen."}, {"field": "uid", "type": "string", "description": "Unique ID for the connection."}, {"field": "id", "type": "conn_id", "description": "The connection\u2019s 4-tuple of endpoint addresses/ports."}, {"field": "nick", "type": "string", "description": "Nickname given for the connection."}, {"field": "user", "type": "string", "description": "Username given for the connection."}, {"field": "command", "type": "string", "description": "Command given by the client."}, {"field": "value", "type": "string", "description": "Value for the command given by the client."}, {"field": "addl", "type": "string", "description": "Any additional data for the command."}, {"field": "dcc_file_name", "type": "string", "description": "(present if base/protocols/irc/dcc-send.bro is loaded)"}, {"field": "dcc_file_size", "type": "count", "description": "(present if base/protocols/irc/dcc-send.bro is loaded)"}, {"field": "dcc_mime_type", "type": "string", "description": "(present if base/protocols/irc/dcc-send.bro is loaded)"}, {"field": "fuid", "type": "string", "description": "(present if base/protocols/irc/files.bro is loaded)"}], "file": "irc.log", "pattern": {"pattern": "%{NUMBER:ts}\\t%{NOTSPACE:uid}\\t%{IP:orig_h}\\t%{INT:orig_p}\\t%{IP:resp_h}\\t%{INT:resp_p}\\t%{GREEDYDATA:nick}\\t%{GREEDYDATA:user}\\t%{GREEDYDATA:command}\\t%{GREEDYDATA:value}\\t%{GREEDYDATA:addl}\\t%{GREEDYDATA:dcc_file_name}\\t%{INT:dcc_file_size}\\t%{GREEDYDATA:dcc_mime_type}\\t%{NOTSPACE:fuid}", "name": "BRO_IRC"}, "log_type": "irc"}, {"description": "Kerberos", "url": "https://www.bro.org/sphinx/scripts/base/protocols/krb/main.bro.html#type-KRB::Info", "fields": [{"field": "ts", "type": "time", "description": "Timestamp for when the event happened."}, {"field": "uid", "type": "string", "description": "Unique ID for the connection."}, {"field": "id", "type": "conn_id", "description": "The connection\u2019s 4-tuple of endpoint addresses/ports."}, {"field": "request_type", "type": "string", "description": "Request type - Authentication Service (\u201cAS\u201d) or\nTicket Granting Service (\u201cTGS\u201d)"}, {"field": "client", "type": "string", "description": "Client"}, {"field": "service", "type": "string", "description": "Service"}, {"field": "success", "type": "bool", "description": "Request result"}, {"field": "error_code", "type": "count", "description": "Error code"}, {"field": "error_msg", "type": "string", "description": "Error message"}, {"field": "from", "type": "time", "description": "Ticket valid from"}, {"field": "till", "type": "time", "description": "Ticket valid till"}, {"field": "cipher", "type": "string", "description": "Ticket encryption type"}, {"field": "forwardable", "type": "bool", "description": "Forwardable ticket requested"}, {"field": "renewable", "type": "bool", "description": "Renewable ticket requested"}, {"field": "logged", "type": "bool", "description": "We\u2019ve already logged this"}, {"field": "client_cert.ts", "type": "time", "description": "The time when the file was first seen."}, {"field": "client_cert.fuid", "type": "string", "description": "An identifier associated with a single file."}, {"field": "client_cert.tx_hosts", "type": "set", "description": "If this file was transferred over a network\nconnection this should show the host or hosts that\nthe data sourced from."}, {"field": "client_cert.rx_hosts", "type": "set", "description": "If this file was transferred over a network\nconnection this should show the host or hosts that\nthe data traveled to."}, {"field": "client_cert.conn_uids", "type": "set", "description": "Connection UIDs over which the file was transferred."}, {"field": "client_cert.source", "type": "string", "description": "An identification of the source of the file data.  E.g. it\nmay be a network protocol over which it was transferred, or a\nlocal file path which was read, or some other input source."}, {"field": "client_cert.depth", "type": "count", "description": "A value to represent the depth of this file in relation\nto its source.  In SMTP, it is the depth of the MIME\nattachment on the message.  In HTTP, it is the depth of the\nrequest within the TCP connection."}, {"field": "client_cert.analyzers", "type": "set", "description": "A set of analysis types done during the file analysis."}, {"field": "client_cert.mime_type", "type": "string", "description": "A mime type provided by the strongest file magic signature\nmatch against the bof_buffer field of fa_file,\nor in the cases where no buffering of the beginning of file\noccurs, an initial guess of the mime type based on the first\ndata seen."}, {"field": "client_cert.filename", "type": "string", "description": "A filename for the file if one is available from the source\nfor the file.  These will frequently come from\n\u201cContent-Disposition\u201d headers in network protocols."}, {"field": "client_cert.duration", "type": "interval", "description": "The duration the file was analyzed for."}, {"field": "client_cert.local_orig", "type": "bool", "description": "If the source of this file is a network connection, this field\nindicates if the data originated from the local network or not as\ndetermined by the configured Site::local_nets."}, {"field": "client_cert.is_orig", "type": "bool", "description": "If the source of this file is a network connection, this field\nindicates if the file is being sent by the originator of the\nconnection or the responder."}, {"field": "client_cert.seen_bytes", "type": "count", "description": "Number of bytes provided to the file analysis engine for the file."}, {"field": "client_cert.total_bytes", "type": "count", "description": "Total number of bytes that are supposed to comprise the full file."}, {"field": "client_cert.missing_bytes", "type": "count", "description": "The number of bytes in the file stream that were completely missed\nduring the process of analysis e.g. due to dropped packets."}, {"field": "client_cert.overflow_bytes", "type": "count", "description": "The number of bytes in the file stream that were not delivered to\nstream file analyzers.  This could be overlapping bytes or\nbytes that couldn\u2019t be reassembled."}, {"field": "client_cert.timedout", "type": "bool", "description": "Whether the file analysis timed out at least once for the file."}, {"field": "client_cert.parent_fuid", "type": "string", "description": "Identifier associated with a container file from which this one was\nextracted as part of the file analysis."}, {"field": "client_cert.md5", "type": "string", "description": "(present if base/files/hash/main.bro is loaded)"}, {"field": "client_cert.sha1", "type": "string", "description": "(present if base/files/hash/main.bro is loaded)"}, {"field": "client_cert.sha256", "type": "string", "description": "(present if base/files/hash/main.bro is loaded)"}, {"field": "client_cert.x509", "type": "X509::Info", "description": "(present if base/files/x509/main.bro is loaded)"}, {"field": "client_cert.extracted", "type": "string", "description": "(present if base/files/extract/main.bro is loaded)"}, {"field": "client_cert.entropy", "type": "double", "description": "(present if policy/frameworks/files/entropy-test-all-files.bro is loaded)"}, {"field": "client_cert_subject", "type": "string", "description": "(present if base/protocols/krb/files.bro is loaded)"}, {"field": "client_cert_fuid", "type": "string", "description": "(present if base/protocols/krb/files.bro is loaded)"}, {"field": "server_cert.ts", "type": "time", "description": "The time when the file was first seen."}, {"field": "server_cert.fuid", "type": "string", "description": "An identifier associated with a single file."}, {"field": "server_cert.tx_hosts", "type": "set", "description": "If this file was transferred over a network\nconnection this should show the host or hosts that\nthe data sourced from."}, {"field": "server_cert.rx_hosts", "type": "set", "description": "If this file was transferred over a network\nconnection this should show the host or hosts that\nthe data traveled to."}, {"field": "server_cert.conn_uids", "type": "set", "description": "Connection UIDs over which the file was transferred."}, {"field": "server_cert.source", "type": "string", "description": "An identification of the source of the file data.  E.g. it\nmay be a network protocol over which it was transferred, or a\nlocal file path which was read, or some other input source."}, {"field": "server_cert.depth", "type": "count", "description": "A value to represent the depth of this file in relation\nto its source.  In SMTP, it is the depth of the MIME\nattachment on the message.  In HTTP, it is the depth of the\nrequest within the TCP connection."}, {"field": "server_cert.analyzers", "type": "set", "description": "A set of analysis types done during the file analysis."}, {"field": "server_cert.mime_type", "type": "string", "description": "A mime type provided by the strongest file magic signature\nmatch against the bof_buffer field of fa_file,\nor in the cases where no buffering of the beginning of file\noccurs, an initial guess of the mime type based on the first\ndata seen."}, {"field": "server_cert.filename", "type": "string", "description": "A filename for the file if one is available from the source\nfor the file.  These will frequently come from\n\u201cContent-Disposition\u201d headers in network protocols."}, {"field": "server_cert.duration", "type": "interval", "description": "The duration the file was analyzed for."}, {"field": "server_cert.local_orig", "type": "bool", "description": "If the source of this file is a network connection, this field\nindicates if the data originated from the local network or not as\ndetermined by the configured Site::local_nets."}, {"field": "server_cert.is_orig", "type": "bool", "description": "If the source of this file is a network connection, this field\nindicates if the file is being sent by the originator of the\nconnection or the responder."}, {"field": "server_cert.seen_bytes", "type": "count", "description": "Number of bytes provided to the file analysis engine for the file."}, {"field": "server_cert.total_bytes", "type": "count", "description": "Total number of bytes that are supposed to comprise the full file."}, {"field": "server_cert.missing_bytes", "type": "count", "description": "The number of bytes in the file stream that were completely missed\nduring the process of analysis e.g. due to dropped packets."}, {"field": "server_cert.overflow_bytes", "type": "count", "description": "The number of bytes in the file stream that were not delivered to\nstream file analyzers.  This could be overlapping bytes or\nbytes that couldn\u2019t be reassembled."}, {"field": "server_cert.timedout", "type": "bool", "description": "Whether the file analysis timed out at least once for the file."}, {"field": "server_cert.parent_fuid", "type": "string", "description": "Identifier associated with a container file from which this one was\nextracted as part of the file analysis."}, {"field": "server_cert.md5", "type": "string", "description": "(present if base/files/hash/main.bro is loaded)"}, {"field": "server_cert.sha1", "type": "string", "description": "(present if base/files/hash/main.bro is loaded)"}, {"field": "server_cert.sha256", "type": "string", "description": "(present if base/files/hash/main.bro is loaded)"}, {"field": "server_cert.x509", "type": "X509::Info", "description": "(present if base/files/x509/main.bro is loaded)"}, {"field": "server_cert.extracted", "type": "string", "description": "(present if base/files/extract/main.bro is loaded)"}, {"field": "server_cert.entropy", "type": "double", "description": "(present if policy/frameworks/files/entropy-test-all-files.bro is loaded)"}, {"field": "server_cert_subject", "type": "string", "description": "(present if base/protocols/krb/files.bro is loaded)"}, {"field": "server_cert_fuid", "type": "string", "description": "(present if base/protocols/krb/files.bro is loaded)"}], "file": "kerberos.log", "pattern": {"pattern": "%{NUMBER:ts}\\t%{NOTSPACE:uid}\\t%{IP:orig_h}\\t%{INT:orig_p}\\t%{IP:resp_h}\\t%{INT:resp_p}\\t%{GREEDYDATA:request_type}\\t%{GREEDYDATA:client}\\t%{GREEDYDATA:service}\\t%{GREEDYDATA:success}\\t%{INT:error_code}\\t%{GREEDYDATA:error_msg}\\t%{NUMBER:from}\\t%{NUMBER:till}\\t%{GREEDYDATA:cipher}\\t%{GREEDYDATA:forwardable}\\t%{GREEDYDATA:renewable}\\t%{GREEDYDATA:logged}\\t%{NUMBER:client_cert.ts}\\t%{NOTSPACE:client_cert.fuid}\\t%{GREEDYDATA:client_cert.tx_hosts}\\t%{GREEDYDATA:client_cert.rx_hosts}\\t%{NOTSPACE:client_cert.conn_uids}\\t%{GREEDYDATA:client_cert.source}\\t%{INT:client_cert.depth}\\t%{GREEDYDATA:client_cert.analyzers}\\t%{GREEDYDATA:client_cert.mime_type}\\t%{GREEDYDATA:client_cert.filename}\\t%{GREEDYDATA:client_cert.duration}\\t%{GREEDYDATA:client_cert.local_orig}\\t%{GREEDYDATA:client_cert.is_orig}\\t%{INT:client_cert.seen_bytes}\\t%{INT:client_cert.total_bytes}\\t%{INT:client_cert.missing_bytes}\\t%{INT:client_cert.overflow_bytes}\\t%{GREEDYDATA:client_cert.timedout}\\t%{NOTSPACE:client_cert.parent_fuid}\\t%{GREEDYDATA:client_cert.md5}\\t%{GREEDYDATA:client_cert.sha1}\\t%{GREEDYDATA:client_cert.sha256}\\t%{GREEDYDATA:client_cert.x509}\\t%{GREEDYDATA:client_cert.extracted}\\t%{GREEDYDATA:client_cert.entropy}\\t%{GREEDYDATA:client_cert_subject}\\t%{NOTSPACE:client_cert_fuid}\\t%{NUMBER:server_cert.ts}\\t%{NOTSPACE:server_cert.fuid}\\t%{GREEDYDATA:server_cert.tx_hosts}\\t%{GREEDYDATA:server_cert.rx_hosts}\\t%{NOTSPACE:server_cert.conn_uids}\\t%{GREEDYDATA:server_cert.source}\\t%{INT:server_cert.depth}\\t%{GREEDYDATA:server_cert.analyzers}\\t%{GREEDYDATA:server_cert.mime_type}\\t%{GREEDYDATA:server_cert.filename}\\t%{GREEDYDATA:server_cert.duration}\\t%{GREEDYDATA:server_cert.local_orig}\\t%{GREEDYDATA:server_cert.is_orig}\\t%{INT:server_cert.seen_bytes}\\t%{INT:server_cert.total_bytes}\\t%{INT:server_cert.missing_bytes}\\t%{INT:server_cert.overflow_bytes}\\t%{GREEDYDATA:server_cert.timedout}\\t%{NOTSPACE:server_cert.parent_fuid}\\t%{GREEDYDATA:server_cert.md5}\\t%{GREEDYDATA:server_cert.sha1}\\t%{GREEDYDATA:server_cert.sha256}\\t%{GREEDYDATA:server_cert.x509}\\t%{GREEDYDATA:server_cert.extracted}\\t%{GREEDYDATA:server_cert.entropy}\\t%{GREEDYDATA:server_cert_subject}\\t%{NOTSPACE:server_cert_fuid}", "name": "BRO_KERBEROS"}, "log_type": "kerberos"}, {"description": "Modbus commands and responses", "url": "https://www.bro.org/sphinx/scripts/base/protocols/modbus/main.bro.html#type-Modbus::Info", "fields": [{"field": "ts", "type": "time", "description": "Time of the request."}, {"field": "uid", "type": "string", "description": "Unique identifier for the connection."}, {"field": "id", "type": "conn_id", "description": "Identifier for the connection."}, {"field": "func", "type": "string", "description": "The name of the function message that was sent."}, {"field": "exception", "type": "string", "description": "The exception if the response was a failure."}, {"field": "track_address", "type": "count", "description": "(present if policy/protocols/modbus/track-memmap.bro is loaded)"}], "file": "modbus.log", "pattern": {"pattern": "%{NUMBER:ts}\\t%{NOTSPACE:uid}\\t%{IP:orig_h}\\t%{INT:orig_p}\\t%{IP:resp_h}\\t%{INT:resp_p}\\t%{GREEDYDATA:func}\\t%{GREEDYDATA:exception}\\t%{INT:track_address}", "name": "BRO_MODBUS"}, "log_type": "modbus"}, {"description": "Tracks changes to Modbus holding\nregisters", "url": "https://www.bro.org/sphinx/scripts/policy/protocols/modbus/track-memmap.bro.html#type-Modbus::MemmapInfo", "fields": [{"field": "ts", "type": "time", "description": "Timestamp for the detected register change."}, {"field": "uid", "type": "string", "description": "Unique ID for the connection."}, {"field": "id", "type": "conn_id", "description": "Connection ID."}, {"field": "register", "type": "count", "description": "The device memory offset."}, {"field": "old_val", "type": "count", "description": "The old value stored in the register."}, {"field": "new_val", "type": "count", "description": "The new value stored in the register."}, {"field": "delta", "type": "interval", "description": "The time delta between when the old_val and new_val were\nseen."}], "file": "modbus_register_change.log", "pattern": {"pattern": "%{NUMBER:ts}\\t%{NOTSPACE:uid}\\t%{IP:orig_h}\\t%{INT:orig_p}\\t%{IP:resp_h}\\t%{INT:resp_p}\\t%{INT:register}\\t%{INT:old_val}\\t%{INT:new_val}\\t%{GREEDYDATA:delta}", "name": "BRO_MODBUS_REGISTER_CHANGE"}, "log_type": "modbus_register_change"}, {"description": "MySQL", "url": "https://www.bro.org/sphinx/scripts/base/protocols/mysql/main.bro.html#type-MySQL::Info", "fields": [{"field": "ts", "type": "time", "description": "Timestamp for when the event happened."}, {"field": "uid", "type": "string", "description": "Unique ID for the connection."}, {"field": "id", "type": "conn_id", "description": "The connection\u2019s 4-tuple of endpoint addresses/ports."}, {"field": "cmd", "type": "string", "description": "The command that was issued"}, {"field": "arg", "type": "string", "description": "The argument issued to the command"}, {"field": "success", "type": "bool", "description": "Did the server tell us that the command succeeded?"}, {"field": "rows", "type": "count", "description": "The number of affected rows, if any"}, {"field": "response", "type": "string", "description": "Server message, if any"}], "file": "mysql.log", "pattern": {"pattern": "%{NUMBER:ts}\\t%{NOTSPACE:uid}\\t%{IP:orig_h}\\t%{INT:orig_p}\\t%{IP:resp_h}\\t%{INT:resp_p}\\t%{GREEDYDATA:cmd}\\t%{GREEDYDATA:arg}\\t%{GREEDYDATA:success}\\t%{INT:rows}\\t%{GREEDYDATA:response}", "name": "BRO_MYSQL"}, "log_type": "mysql"}, {"description": "NT LAN Manager (NTLM)", "url": "https://www.bro.org/sphinx/scripts/base/protocols/ntlm/main.bro.html#type-NTLM::Info", "fields": [{"field": "ts", "type": "time", "description": "Timestamp for when the event happened."}, {"field": "uid", "type": "string", "description": "Unique ID for the connection."}, {"field": "id", "type": "conn_id", "description": "The connection\u2019s 4-tuple of endpoint addresses/ports."}, {"field": "username", "type": "string", "description": "Username given by the client."}, {"field": "hostname", "type": "string", "description": "Hostname given by the client."}, {"field": "domainname", "type": "string", "description": "Domainname given by the client."}, {"field": "success", "type": "bool", "description": "Indicate whether or not the authentication was successful."}, {"field": "status", "type": "string", "description": "A string representation of the status code that was\nreturned in response to the authentication attempt."}, {"field": "done", "type": "bool", "description": "Internally used field to indicate if the login attempt\nhas already been logged."}], "file": "ntlm.log", "pattern": {"pattern": "%{NUMBER:ts}\\t%{NOTSPACE:uid}\\t%{IP:orig_h}\\t%{INT:orig_p}\\t%{IP:resp_h}\\t%{INT:resp_p}\\t%{GREEDYDATA:username}\\t%{GREEDYDATA:hostname}\\t%{GREEDYDATA:domainname}\\t%{GREEDYDATA:success}\\t%{GREEDYDATA:status}\\t%{GREEDYDATA:done}", "name": "BRO_NTLM"}, "log_type": "ntlm"}, {"description": "RADIUS authentication attempts", "url": "https://www.bro.org/sphinx/scripts/base/protocols/radius/main.bro.html#type-RADIUS::Info", "fields": [{"field": "ts", "type": "time", "description": "Timestamp for when the event happened."}, {"field": "uid", "type": "string", "description": "Unique ID for the connection."}, {"field": "id", "type": "conn_id", "description": "The connection\u2019s 4-tuple of endpoint addresses/ports."}, {"field": "username", "type": "string", "description": "The username, if present."}, {"field": "mac", "type": "string", "description": "MAC address, if present."}, {"field": "remote_ip", "type": "addr", "description": "Remote IP address, if present."}, {"field": "connect_info", "type": "string", "description": "Connect info, if present."}, {"field": "result", "type": "string", "description": "Successful or failed authentication."}, {"field": "logged", "type": "bool", "description": "Whether this has already been logged and can be ignored."}], "file": "radius.log", "pattern": {"pattern": "%{NUMBER:ts}\\t%{NOTSPACE:uid}\\t%{IP:orig_h}\\t%{INT:orig_p}\\t%{IP:resp_h}\\t%{INT:resp_p}\\t%{GREEDYDATA:username}\\t%{GREEDYDATA:mac}\\t%{IP:remote_ip}\\t%{GREEDYDATA:connect_info}\\t%{GREEDYDATA:result}\\t%{GREEDYDATA:logged}", "name": "BRO_RADIUS"}, "log_type": "radius"}, {"description": "RDP", "url": "https://www.bro.org/sphinx/scripts/base/protocols/rdp/main.bro.html#type-RDP::Info", "fields": [{"field": "ts", "type": "time", "description": "Timestamp for when the event happened."}, {"field": "uid", "type": "string", "description": "Unique ID for the connection."}, {"field": "id", "type": "conn_id", "description": "The connection\u2019s 4-tuple of endpoint addresses/ports."}, {"field": "cookie", "type": "string", "description": "Cookie value used by the client machine.\nThis is typically a username."}, {"field": "result", "type": "string", "description": "Status result for the connection.  It\u2019s a mix between\nRDP negotation failure messages and GCC server create\nresponse messages."}, {"field": "security_protocol", "type": "string", "description": "Security protocol chosen by the server."}, {"field": "keyboard_layout", "type": "string", "description": "Keyboard layout (language) of the client machine."}, {"field": "client_build", "type": "string", "description": "RDP client version used by the client machine."}, {"field": "client_name", "type": "string", "description": "Name of the client machine."}, {"field": "client_dig_product_id", "type": "string", "description": "Product ID of the client machine."}, {"field": "desktop_width", "type": "count", "description": "Desktop width of the client machine."}, {"field": "desktop_height", "type": "count", "description": "Desktop height of the client machine."}, {"field": "requested_color_depth", "type": "string", "description": "The color depth requested by the client in\nthe high_color_depth field."}, {"field": "cert_type", "type": "string", "description": "If the connection is being encrypted with native\nRDP encryption, this is the type of cert\nbeing used."}, {"field": "cert_count", "type": "count", "description": "The number of certs seen.  X.509 can transfer an\nentire certificate chain."}, {"field": "cert_permanent", "type": "bool", "description": "Indicates if the provided certificate or certificate\nchain is permanent or temporary."}, {"field": "encryption_level", "type": "string", "description": "Encryption level of the connection."}, {"field": "encryption_method", "type": "string", "description": "Encryption method of the connection."}, {"field": "analyzer_id", "type": "count", "description": "The analyzer ID used for the analyzer instance attached\nto each connection.  It is not used for logging since it\u2019s a\nmeaningless arbitrary number."}, {"field": "done", "type": "bool", "description": "Track status of logging RDP connections."}, {"field": "ssl", "type": "bool", "description": "(present if policy/protocols/rdp/indicate_ssl.bro is loaded)"}], "file": "rdp.log", "pattern": {"pattern": "%{NUMBER:ts}\\t%{NOTSPACE:uid}\\t%{IP:orig_h}\\t%{INT:orig_p}\\t%{IP:resp_h}\\t%{INT:resp_p}\\t%{GREEDYDATA:cookie}\\t%{GREEDYDATA:result}\\t%{GREEDYDATA:security_protocol}\\t%{GREEDYDATA:keyboard_layout}\\t%{GREEDYDATA:client_build}\\t%{GREEDYDATA:client_name}\\t%{GREEDYDATA:client_dig_product_id}\\t%{INT:desktop_width}\\t%{INT:desktop_height}\\t%{GREEDYDATA:requested_color_depth}\\t%{GREEDYDATA:cert_type}\\t%{INT:cert_count}\\t%{GREEDYDATA:cert_permanent}\\t%{GREEDYDATA:encryption_level}\\t%{GREEDYDATA:encryption_method}\\t%{INT:analyzer_id}\\t%{GREEDYDATA:done}\\t%{GREEDYDATA:ssl}", "name": "BRO_RDP"}, "log_type": "rdp"}, {"description": "Remote Framebuffer (RFB)", "url": "https://www.bro.org/sphinx/scripts/base/protocols/rfb/main.bro.html#type-RFB::Info", "fields": [{"field": "ts", "type": "time", "description": "Timestamp for when the event happened."}, {"field": "uid", "type": "string", "description": "Unique ID for the connection."}, {"field": "id", "type": "conn_id", "description": "The connection\u2019s 4-tuple of endpoint addresses/ports."}, {"field": "client_major_version", "type": "string", "description": "Major version of the client."}, {"field": "client_minor_version", "type": "string", "description": "Minor version of the client."}, {"field": "server_major_version", "type": "string", "description": "Major version of the server."}, {"field": "server_minor_version", "type": "string", "description": "Minor version of the server."}, {"field": "authentication_method", "type": "string", "description": "Identifier of authentication method used."}, {"field": "auth", "type": "bool", "description": "Whether or not authentication was successful."}, {"field": "share_flag", "type": "bool", "description": "Whether the client has an exclusive or a shared session."}, {"field": "desktop_name", "type": "string", "description": "Name of the screen that is being shared."}, {"field": "width", "type": "count", "description": "Width of the screen that is being shared."}, {"field": "height", "type": "count", "description": "Height of the screen that is being shared."}, {"field": "done", "type": "bool", "description": "Internally used value to determine if this connection\nhas already been logged."}], "file": "rfb.log", "pattern": {"pattern": "%{NUMBER:ts}\\t%{NOTSPACE:uid}\\t%{IP:orig_h}\\t%{INT:orig_p}\\t%{IP:resp_h}\\t%{INT:resp_p}\\t%{GREEDYDATA:client_major_version}\\t%{GREEDYDATA:client_minor_version}\\t%{GREEDYDATA:server_major_version}\\t%{GREEDYDATA:server_minor_version}\\t%{GREEDYDATA:authentication_method}\\t%{GREEDYDATA:auth}\\t%{GREEDYDATA:share_flag}\\t%{GREEDYDATA:desktop_name}\\t%{INT:width}\\t%{INT:height}\\t%{GREEDYDATA:done}", "name": "BRO_RFB"}, "log_type": "rfb"}, {"description": "SIP", "url": "https://www.bro.org/sphinx/scripts/base/protocols/sip/main.bro.html#type-SIP::Info", "fields": [{"field": "ts", "type": "time", "description": "Timestamp for when the request happened."}, {"field": "uid", "type": "string", "description": "Unique ID for the connection."}, {"field": "id", "type": "conn_id", "description": "The connection\u2019s 4-tuple of endpoint addresses/ports."}, {"field": "trans_depth", "type": "count", "description": "Represents the pipelined depth into the connection of this\nrequest/response transaction."}, {"field": "method", "type": "string", "description": "Verb used in the SIP request (INVITE, REGISTER etc.)."}, {"field": "uri", "type": "string", "description": "URI used in the request."}, {"field": "date", "type": "string", "description": "Contents of the Date: header from the client"}, {"field": "request_from", "type": "string", "description": "Contents of the request From: header\nNote: The tag= value that\u2019s usually appended to the sender\nis stripped off and not logged."}, {"field": "request_to", "type": "string", "description": "Contents of the To: header"}, {"field": "response_from", "type": "string", "description": "Contents of the response From: header\nNote: The tag= value that\u2019s usually appended to the sender\nis stripped off and not logged."}, {"field": "response_to", "type": "string", "description": "Contents of the response To: header"}, {"field": "reply_to", "type": "string", "description": "Contents of the Reply-To: header"}, {"field": "call_id", "type": "string", "description": "Contents of the Call-ID: header from the client"}, {"field": "seq", "type": "string", "description": "Contents of the CSeq: header from the client"}, {"field": "subject", "type": "string", "description": "Contents of the Subject: header from the client"}, {"field": "request_path", "type": "vector", "description": "The client message transmission path, as extracted from the headers."}, {"field": "response_path", "type": "vector", "description": "The server message transmission path, as extracted from the headers."}, {"field": "user_agent", "type": "string", "description": "Contents of the User-Agent: header from the client"}, {"field": "status_code", "type": "count", "description": "Status code returned by the server."}, {"field": "status_msg", "type": "string", "description": "Status message returned by the server."}, {"field": "warning", "type": "string", "description": "Contents of the Warning: header"}, {"field": "request_body_len", "type": "count", "description": "Contents of the Content-Length: header from the client"}, {"field": "response_body_len", "type": "count", "description": "Contents of the Content-Length: header from the server"}, {"field": "content_type", "type": "string", "description": "Contents of the Content-Type: header from the server"}], "file": "sip.log", "pattern": {"pattern": "%{NUMBER:ts}\\t%{NOTSPACE:uid}\\t%{IP:orig_h}\\t%{INT:orig_p}\\t%{IP:resp_h}\\t%{INT:resp_p}\\t%{INT:trans_depth}\\t%{GREEDYDATA:method}\\t%{GREEDYDATA:uri}\\t%{GREEDYDATA:date}\\t%{GREEDYDATA:request_from}\\t%{GREEDYDATA:request_to}\\t%{GREEDYDATA:response_from}\\t%{GREEDYDATA:response_to}\\t%{GREEDYDATA:reply_to}\\t%{GREEDYDATA:call_id}\\t%{GREEDYDATA:seq}\\t%{GREEDYDATA:subject}\\t%{GREEDYDATA:request_path}\\t%{GREEDYDATA:response_path}\\t%{GREEDYDATA:user_agent}\\t%{INT:status_code}\\t%{GREEDYDATA:status_msg}\\t%{GREEDYDATA:warning}\\t%{INT:request_body_len}\\t%{INT:response_body_len}\\t%{GREEDYDATA:content_type}", "name": "BRO_SIP"}, "log_type": "sip"}, {"description": "SMB commands", "url": "https://www.bro.org/sphinx/scripts/policy/protocols/smb/main.bro.html#type-SMB::CmdInfo", "fields": [{"field": "ts", "type": "time", "description": "Timestamp of the command request."}, {"field": "uid", "type": "string", "description": "Unique ID of the connection the request was sent over."}, {"field": "id", "type": "conn_id", "description": "ID of the connection the request was sent over."}, {"field": "command", "type": "string", "description": "The command sent by the client."}, {"field": "sub_command", "type": "string", "description": "The subcommand sent by the client, if present."}, {"field": "argument", "type": "string", "description": "Command argument sent by the client, if any."}, {"field": "status", "type": "string", "description": "Server reply to the client\u2019s command."}, {"field": "rtt", "type": "interval", "description": "Round trip time from the request to the response."}, {"field": "version", "type": "string", "description": "Version of SMB for the command."}, {"field": "username", "type": "string", "description": "Authenticated username, if available."}, {"field": "tree", "type": "string", "description": "If this is related to a tree, this is the tree\nthat was used for the current command."}, {"field": "tree_service", "type": "string", "description": "The type of tree (disk share, printer share, named pipe, etc.)."}, {"field": "referenced_file.ts", "type": "time", "description": "Time when the file was first discovered."}, {"field": "referenced_file.uid", "type": "string", "description": "Unique ID of the connection the file was sent over."}, {"field": "referenced_file.id", "type": "conn_id", "description": "ID of the connection the file was sent over."}, {"field": "referenced_file.fuid", "type": "string", "description": "Unique ID of the file."}, {"field": "referenced_file.action", "type": "SMB::Action", "description": "Action this log record represents."}, {"field": "referenced_file.path", "type": "string", "description": "Path pulled from the tree this file was transferred to or from."}, {"field": "referenced_file.name", "type": "string", "description": "Filename if one was seen."}, {"field": "referenced_file.size", "type": "count", "description": "Total size of the file."}, {"field": "referenced_file.prev_name", "type": "string", "description": "If the rename action was seen, this will be\nthe file\u2019s previous name."}, {"field": "referenced_file.times", "type": "SMB::MACTimes", "description": "Last time this file was modified."}, {"field": "referenced_file.fid", "type": "count", "description": "ID referencing this file."}, {"field": "referenced_file.uuid", "type": "string", "description": "UUID referencing this file if DCE/RPC."}, {"field": "referenced_tree.ts", "type": "time", "description": "Time when the tree was mapped."}, {"field": "referenced_tree.uid", "type": "string", "description": "Unique ID of the connection the tree was mapped over."}, {"field": "referenced_tree.id", "type": "conn_id", "description": "ID of the connection the tree was mapped over."}, {"field": "referenced_tree.path", "type": "string", "description": "Name of the tree path."}, {"field": "referenced_tree.service", "type": "string", "description": "The type of resource of the tree (disk share, printer share, named pipe, etc.)."}, {"field": "referenced_tree.native_file_system", "type": "string", "description": "File system of the tree."}, {"field": "referenced_tree.share_type", "type": "string", "description": "If this is SMB2, a share type will be included.  For SMB1,\nthe type of share will be deduced and included as well."}, {"field": "smb1_offered_dialects", "type": "string_vec", "description": "(present if policy/protocols/smb/smb1-main.bro is loaded)"}, {"field": "smb2_offered_dialects", "type": "index_vec", "description": "(present if policy/protocols/smb/smb2-main.bro is loaded)"}], "file": "smb_cmd.log", "pattern": {"pattern": "%{NUMBER:ts}\\t%{NOTSPACE:uid}\\t%{IP:orig_h}\\t%{INT:orig_p}\\t%{IP:resp_h}\\t%{INT:resp_p}\\t%{GREEDYDATA:command}\\t%{GREEDYDATA:sub_command}\\t%{GREEDYDATA:argument}\\t%{GREEDYDATA:status}\\t%{GREEDYDATA:rtt}\\t%{GREEDYDATA:version}\\t%{GREEDYDATA:username}\\t%{GREEDYDATA:tree}\\t%{GREEDYDATA:tree_service}\\t%{NUMBER:referenced_file.ts}\\t%{NOTSPACE:referenced_file.uid}\\t%{NOTSPACE:referenced_file.id}\\t%{NOTSPACE:referenced_file.fuid}\\t%{GREEDYDATA:referenced_file.action}\\t%{GREEDYDATA:referenced_file.path}\\t%{GREEDYDATA:referenced_file.name}\\t%{INT:referenced_file.size}\\t%{GREEDYDATA:referenced_file.prev_name}\\t%{GREEDYDATA:referenced_file.times}\\t%{INT:referenced_file.fid}\\t%{NOTSPACE:referenced_file.uuid}\\t%{NUMBER:referenced_tree.ts}\\t%{NOTSPACE:referenced_tree.uid}\\t%{NOTSPACE:referenced_tree.id}\\t%{GREEDYDATA:referenced_tree.path}\\t%{GREEDYDATA:referenced_tree.service}\\t%{GREEDYDATA:referenced_tree.native_file_system}\\t%{GREEDYDATA:referenced_tree.share_type}\\t%{GREEDYDATA:smb1_offered_dialects}\\t%{GREEDYDATA:smb2_offered_dialects}", "name": "BRO_SMB_CMD"}, "log_type": "smb_cmd"}, {"description": "SMB files", "url": "https://www.bro.org/sphinx/scripts/policy/protocols/smb/main.bro.html#type-SMB::FileInfo", "fields": [{"field": "ts", "type": "time", "description": "Time when the file was first discovered."}, {"field": "uid", "type": "string", "description": "Unique ID of the connection the file was sent over."}, {"field": "id", "type": "conn_id", "description": "ID of the connection the file was sent over."}, {"field": "fuid", "type": "string", "description": "Unique ID of the file."}, {"field": "action", "type": "SMB::Action", "description": ""}, {"field": "path", "type": "string", "description": "Path pulled from the tree this file was transferred to or from."}, {"field": "name", "type": "string", "description": "Filename if one was seen."}, {"field": "size", "type": "count", "description": "Total size of the file."}, {"field": "prev_name", "type": "string", "description": "If the rename action was seen, this will be\nthe file\u2019s previous name."}, {"field": "times.modified", "type": "time", "description": "The time when data was last written to the file."}, {"field": "times.accessed", "type": "time", "description": "The time when the file was last accessed."}, {"field": "times.created", "type": "time", "description": "The time the file was created."}, {"field": "times.changed", "type": "time", "description": "The time when the file was last modified."}, {"field": "fid", "type": "count", "description": "ID referencing this file."}, {"field": "uuid", "type": "string", "description": "UUID referencing this file if DCE/RPC."}], "file": "smb_files.log", "pattern": {"pattern": "%{NUMBER:ts}\\t%{NOTSPACE:uid}\\t%{IP:orig_h}\\t%{INT:orig_p}\\t%{IP:resp_h}\\t%{INT:resp_p}\\t%{NOTSPACE:fuid}\\t%{GREEDYDATA:action}\\t%{GREEDYDATA:path}\\t%{GREEDYDATA:name}\\t%{INT:size}\\t%{GREEDYDATA:prev_name}\\t%{NUMBER:times.modified}\\t%{NUMBER:times.accessed}\\t%{NUMBER:times.created}\\t%{NUMBER:times.changed}\\t%{INT:fid}\\t%{NOTSPACE:uuid}", "name": "BRO_SMB_FILES"}, "log_type": "smb_files"}, {"description": "SMB trees", "url": "https://www.bro.org/sphinx/scripts/policy/protocols/smb/main.bro.html#type-SMB::TreeInfo", "fields": [{"field": "ts", "type": "time", "description": "Time when the tree was mapped."}, {"field": "uid", "type": "string", "description": "Unique ID of the connection the tree was mapped over."}, {"field": "id", "type": "conn_id", "description": "ID of the connection the tree was mapped over."}, {"field": "path", "type": "string", "description": "Name of the tree path."}, {"field": "service", "type": "string", "description": "The type of resource of the tree (disk share, printer share, named pipe, etc.)."}, {"field": "native_file_system", "type": "string", "description": "File system of the tree."}, {"field": "share_type", "type": "string", "description": "If this is SMB2, a share type will be included.  For SMB1,\nthe type of share will be deduced and included as well."}], "file": "smb_mapping.log", "pattern": {"pattern": "%{NUMBER:ts}\\t%{NOTSPACE:uid}\\t%{IP:orig_h}\\t%{INT:orig_p}\\t%{IP:resp_h}\\t%{INT:resp_p}\\t%{GREEDYDATA:path}\\t%{GREEDYDATA:service}\\t%{GREEDYDATA:native_file_system}\\t%{GREEDYDATA:share_type}", "name": "BRO_SMB_MAPPING"}, "log_type": "smb_mapping"}, {"description": "SMTP transactions", "url": "https://www.bro.org/sphinx/scripts/base/protocols/smtp/main.bro.html#type-SMTP::Info", "fields": [{"field": "ts", "type": "time", "description": "Time when the message was first seen."}, {"field": "uid", "type": "string", "description": "Unique ID for the connection."}, {"field": "id", "type": "conn_id", "description": "The connection\u2019s 4-tuple of endpoint addresses/ports."}, {"field": "trans_depth", "type": "count", "description": "A count to represent the depth of this message transaction in\na single connection where multiple messages were transferred."}, {"field": "helo", "type": "string", "description": "Contents of the Helo header."}, {"field": "mailfrom", "type": "string", "description": "Email addresses found in the From header."}, {"field": "rcptto", "type": "set", "description": "Email addresses found in the Rcpt header."}, {"field": "date", "type": "string", "description": "Contents of the Date header."}, {"field": "from", "type": "string", "description": "Contents of the From header."}, {"field": "to", "type": "set", "description": "Contents of the To header."}, {"field": "cc", "type": "set", "description": "Contents of the CC header."}, {"field": "reply_to", "type": "string", "description": "Contents of the ReplyTo header."}, {"field": "msg_id", "type": "string", "description": "Contents of the MsgID header."}, {"field": "in_reply_to", "type": "string", "description": "Contents of the In-Reply-To header."}, {"field": "subject", "type": "string", "description": "Contents of the Subject header."}, {"field": "x_originating_ip", "type": "addr", "description": "Contents of the X-Originating-IP header."}, {"field": "first_received", "type": "string", "description": "Contents of the first Received header."}, {"field": "second_received", "type": "string", "description": "Contents of the second Received header."}, {"field": "last_reply", "type": "string", "description": "The last message that the server sent to the client."}, {"field": "path", "type": "vector", "description": "The message transmission path, as extracted from the headers."}, {"field": "user_agent", "type": "string", "description": "Value of the User-Agent header from the client."}, {"field": "tls", "type": "bool", "description": "Indicates that the connection has switched to using TLS."}, {"field": "process_received_from", "type": "bool", "description": "Indicates if the \u201cReceived: from\u201d headers should still be\nprocessed."}, {"field": "has_client_activity", "type": "bool", "description": "Indicates if client activity has been seen, but not yet logged."}, {"field": "entity.filename", "type": "string", "description": "Filename for the entity if discovered from a header."}, {"field": "entity.excerpt", "type": "string", "description": "(present if policy/protocols/smtp/entities-excerpt.bro is loaded)"}, {"field": "fuids", "type": "vector", "description": "(present if base/protocols/smtp/files.bro is loaded)"}, {"field": "is_webmail", "type": "bool", "description": "(present if policy/protocols/smtp/software.bro is loaded)"}], "file": "smtp.log", "pattern": {"pattern": "%{NUMBER:ts}\\t%{NOTSPACE:uid}\\t%{IP:orig_h}\\t%{INT:orig_p}\\t%{IP:resp_h}\\t%{INT:resp_p}\\t%{INT:trans_depth}\\t%{GREEDYDATA:helo}\\t%{GREEDYDATA:mailfrom}\\t%{GREEDYDATA:rcptto}\\t%{GREEDYDATA:date}\\t%{GREEDYDATA:from}\\t%{GREEDYDATA:to}\\t%{GREEDYDATA:cc}\\t%{GREEDYDATA:reply_to}\\t%{GREEDYDATA:msg_id}\\t%{GREEDYDATA:in_reply_to}\\t%{GREEDYDATA:subject}\\t%{IP:x_originating_ip}\\t%{GREEDYDATA:first_received}\\t%{GREEDYDATA:second_received}\\t%{GREEDYDATA:last_reply}\\t%{GREEDYDATA:path}\\t%{GREEDYDATA:user_agent}\\t%{GREEDYDATA:tls}\\t%{GREEDYDATA:process_received_from}\\t%{GREEDYDATA:has_client_activity}\\t%{GREEDYDATA:entity.filename}\\t%{GREEDYDATA:entity.excerpt}\\t%{NOTSPACE:fuids}\\t%{GREEDYDATA:is_webmail}", "name": "BRO_SMTP"}, "log_type": "smtp"}, {"description": "SNMP messages", "url": "https://www.bro.org/sphinx/scripts/base/protocols/snmp/main.bro.html#type-SNMP::Info", "fields": [{"field": "ts", "type": "time", "description": "Timestamp of first packet belonging to the SNMP session."}, {"field": "uid", "type": "string", "description": "The unique ID for the connection."}, {"field": "id", "type": "conn_id", "description": "The connection\u2019s 5-tuple of addresses/ports (ports inherently\ninclude transport protocol information)"}, {"field": "duration", "type": "interval", "description": "The amount of time between the first packet beloning to\nthe SNMP session and the latest one seen."}, {"field": "version", "type": "string", "description": "The version of SNMP being used."}, {"field": "community", "type": "string", "description": "The community string of the first SNMP packet associated with\nthe session.  This is used as part of SNMP\u2019s (v1 and v2c)\nadministrative/security framework.  See RFC 1157 or RFC 1901."}, {"field": "get_requests", "type": "count", "description": "The number of variable bindings in GetRequest/GetNextRequest PDUs\nseen for the session."}, {"field": "get_bulk_requests", "type": "count", "description": "The number of variable bindings in GetBulkRequest PDUs seen for\nthe session."}, {"field": "get_responses", "type": "count", "description": "The number of variable bindings in GetResponse/Response PDUs seen\nfor the session."}, {"field": "set_requests", "type": "count", "description": "The number of variable bindings in SetRequest PDUs seen for\nthe session."}, {"field": "display_string", "type": "string", "description": "A system description of the SNMP responder endpoint."}, {"field": "up_since", "type": "time", "description": "The time at which the SNMP responder endpoint claims it\u2019s been\nup since."}], "file": "snmp.log", "pattern": {"pattern": "%{NUMBER:ts}\\t%{NOTSPACE:uid}\\t%{IP:orig_h}\\t%{INT:orig_p}\\t%{IP:resp_h}\\t%{INT:resp_p}\\t%{GREEDYDATA:duration}\\t%{GREEDYDATA:version}\\t%{GREEDYDATA:community}\\t%{INT:get_requests}\\t%{INT:get_bulk_requests}\\t%{INT:get_responses}\\t%{INT:set_requests}\\t%{GREEDYDATA:display_string}\\t%{NUMBER:up_since}", "name": "BRO_SNMP"}, "log_type": "snmp"}, {"description": "SOCKS proxy requests", "url": "https://www.bro.org/sphinx/scripts/base/protocols/socks/main.bro.html#type-SOCKS::Info", "fields": [{"field": "ts", "type": "time", "description": "Time when the proxy connection was first detected."}, {"field": "uid", "type": "string", "description": "Unique ID for the tunnel - may correspond to connection uid\nor be non-existent."}, {"field": "id", "type": "conn_id", "description": "The connection\u2019s 4-tuple of endpoint addresses/ports."}, {"field": "version", "type": "count", "description": "Protocol version of SOCKS."}, {"field": "user", "type": "string", "description": "Username used to request a login to the proxy."}, {"field": "password", "type": "string", "description": "Password used to request a login to the proxy."}, {"field": "status", "type": "string", "description": "Server status for the attempt at using the proxy."}, {"field": "request.host", "type": "addr", "description": ""}, {"field": "request.name", "type": "string", "description": ""}, {"field": "request_p", "type": "port", "description": "Client requested port."}, {"field": "bound.host", "type": "addr", "description": ""}, {"field": "bound.name", "type": "string", "description": ""}, {"field": "bound_p", "type": "port", "description": "Server bound port."}], "file": "socks.log", "pattern": {"pattern": "%{NUMBER:ts}\\t%{NOTSPACE:uid}\\t%{IP:orig_h}\\t%{INT:orig_p}\\t%{IP:resp_h}\\t%{INT:resp_p}\\t%{INT:version}\\t%{GREEDYDATA:user}\\t%{GREEDYDATA:password}\\t%{GREEDYDATA:status}\\t%{IP:request.host}\\t%{GREEDYDATA:request.name}\\t%{INT:request_p}\\t%{IP:bound.host}\\t%{GREEDYDATA:bound.name}\\t%{INT:bound_p}", "name": "BRO_SOCKS"}, "log_type": "socks"}, {"description": "SSH connections", "url": "https://www.bro.org/sphinx/scripts/base/protocols/ssh/main.bro.html#type-SSH::Info", "fields": [{"field": "ts", "type": "time", "description": "Time when the SSH connection began."}, {"field": "uid", "type": "string", "description": "Unique ID for the connection."}, {"field": "id", "type": "conn_id", "description": "The connection\u2019s 4-tuple of endpoint addresses/ports."}, {"field": "version", "type": "count", "description": "SSH major version (1 or 2)"}, {"field": "auth_success", "type": "bool", "description": "Authentication result (T=success, F=failure, unset=unknown)"}, {"field": "auth_attempts", "type": "count", "description": "The number of authentication attemps we observed. There\u2019s always\nat least one, since some servers might support no authentication at all.\nIt\u2019s important to note that not all of these are failures, since\nsome servers require two-factor auth (e.g. password AND pubkey)"}, {"field": "direction", "type": "Direction", "description": "Direction of the connection. If the client was a local host\nlogging into an external host, this would be OUTBOUND. INBOUND\nwould be set for the opposite situation."}, {"field": "client", "type": "string", "description": "The client\u2019s version string"}, {"field": "server", "type": "string", "description": "The server\u2019s version string"}, {"field": "cipher_alg", "type": "string", "description": "The encryption algorithm in use"}, {"field": "mac_alg", "type": "string", "description": "The signing (MAC) algorithm in use"}, {"field": "compression_alg", "type": "string", "description": "The compression algorithm in use"}, {"field": "kex_alg", "type": "string", "description": "The key exchange algorithm in use"}, {"field": "host_key_alg", "type": "string", "description": "The server host key\u2019s algorithm"}, {"field": "host_key", "type": "string", "description": "The server\u2019s key fingerprint"}], "file": "ssh.log", "pattern": {"pattern": "%{NUMBER:ts}\\t%{NOTSPACE:uid}\\t%{IP:orig_h}\\t%{INT:orig_p}\\t%{IP:resp_h}\\t%{INT:resp_p}\\t%{INT:version}\\t%{GREEDYDATA:auth_success}\\t%{INT:auth_attempts}\\t%{GREEDYDATA:direction}\\t%{GREEDYDATA:client}\\t%{GREEDYDATA:server}\\t%{GREEDYDATA:cipher_alg}\\t%{GREEDYDATA:mac_alg}\\t%{GREEDYDATA:compression_alg}\\t%{GREEDYDATA:kex_alg}\\t%{GREEDYDATA:host_key_alg}\\t%{GREEDYDATA:host_key}", "name": "BRO_SSH"}, "log_type": "ssh"}, {"description": "SSL/TLS handshake info", "url": "https://www.bro.org/sphinx/scripts/base/protocols/ssl/main.bro.html#type-SSL::Info", "fields": [{"field": "ts", "type": "time", "description": "Time when the SSL connection was first detected."}, {"field": "uid", "type": "string", "description": "Unique ID for the connection."}, {"field": "id", "type": "conn_id", "description": "The connection\u2019s 4-tuple of endpoint addresses/ports."}, {"field": "version_num", "type": "count", "description": "Numeric SSL/TLS version that the server chose."}, {"field": "version", "type": "string", "description": "SSL/TLS version that the server chose."}, {"field": "cipher", "type": "string", "description": "SSL/TLS cipher suite that the server chose."}, {"field": "curve", "type": "string", "description": "Elliptic curve the server chose when using ECDH/ECDHE."}, {"field": "server_name", "type": "string", "description": "Value of the Server Name Indicator SSL/TLS extension.  It\nindicates the server name that the client was requesting."}, {"field": "session_id", "type": "string", "description": "Session ID offered by the client for session resumption.\nNot used for logging."}, {"field": "resumed", "type": "bool", "description": "Flag to indicate if the session was resumed reusing\nthe key material exchanged in an earlier connection."}, {"field": "client_ticket_empty_session_seen", "type": "bool", "description": "Flag to indicate if we saw a non-empty session ticket being\nsent by the client using an empty session ID. This value\nis used to determine if a session is being resumed. It\u2019s\nnot logged."}, {"field": "client_key_exchange_seen", "type": "bool", "description": "Flag to indicate if we saw a client key exchange message sent\nby the client. This value is used to determine if a session\nis being resumed. It\u2019s not logged."}, {"field": "server_appdata", "type": "count", "description": "Count to track if the server already sent an application data\npacket for TLS 1.3. Used to track when a session was established."}, {"field": "client_appdata", "type": "bool", "description": "Flag to track if the client already sent an application data\npacket for TLS 1.3. Used to track when a session was established."}, {"field": "last_alert", "type": "string", "description": "Last alert that was seen during the connection."}, {"field": "next_protocol", "type": "string", "description": "Next protocol the server chose using the application layer\nnext protocol extension, if present."}, {"field": "analyzer_id", "type": "count", "description": "The analyzer ID used for the analyzer instance attached\nto each connection.  It is not used for logging since it\u2019s a\nmeaningless arbitrary number."}, {"field": "established", "type": "bool", "description": "Flag to indicate if this ssl session has been established\nsuccessfully, or if it was aborted during the handshake."}, {"field": "logged", "type": "bool", "description": "Flag to indicate if this record already has been logged, to\nprevent duplicates."}], "file": "ssl.log", "pattern": {"pattern": "%{NUMBER:ts}\\t%{NOTSPACE:uid}\\t%{IP:orig_h}\\t%{INT:orig_p}\\t%{IP:resp_h}\\t%{INT:resp_p}\\t%{INT:version_num}\\t%{GREEDYDATA:version}\\t%{GREEDYDATA:cipher}\\t%{GREEDYDATA:curve}\\t%{GREEDYDATA:server_name}\\t%{GREEDYDATA:session_id}\\t%{GREEDYDATA:resumed}\\t%{GREEDYDATA:client_ticket_empty_session_seen}\\t%{GREEDYDATA:client_key_exchange_seen}\\t%{INT:server_appdata}\\t%{GREEDYDATA:client_appdata}\\t%{GREEDYDATA:last_alert}\\t%{GREEDYDATA:next_protocol}\\t%{INT:analyzer_id}\\t%{GREEDYDATA:established}\\t%{GREEDYDATA:logged}", "name": "BRO_SSL"}, "log_type": "ssl"}, {"description": "Syslog messages", "url": "https://www.bro.org/sphinx/scripts/base/protocols/syslog/main.bro.html#type-Syslog::Info", "fields": [{"field": "ts", "type": "time", "description": "Timestamp when the syslog message was seen."}, {"field": "uid", "type": "string", "description": "Unique ID for the connection."}, {"field": "id", "type": "conn_id", "description": "The connection\u2019s 4-tuple of endpoint addresses/ports."}, {"field": "proto", "type": "transport_proto", "description": "Protocol over which the message was seen."}, {"field": "facility", "type": "string", "description": "Syslog facility for the message."}, {"field": "severity", "type": "string", "description": "Syslog severity for the message."}, {"field": "message", "type": "string", "description": "The plain text message."}], "file": "syslog.log", "pattern": {"pattern": "%{NUMBER:ts}\\t%{NOTSPACE:uid}\\t%{IP:orig_h}\\t%{INT:orig_p}\\t%{IP:resp_h}\\t%{INT:resp_p}\\t%{WORD:proto}\\t%{GREEDYDATA:facility}\\t%{GREEDYDATA:severity}\\t%{GREEDYDATA:message}", "name": "BRO_SYSLOG"}, "log_type": "syslog"}, {"description": "Tunneling protocol events", "url": "https://www.bro.org/sphinx/scripts/base/frameworks/tunnels/main.bro.html#type-Tunnel::Info", "fields": [{"field": "ts", "type": "time", "description": "Time at which some tunnel activity occurred."}, {"field": "uid", "type": "string", "description": "The unique identifier for the tunnel, which may correspond\nto a connection\u2018s uid field for non-IP-in-IP tunnels.\nThis is optional because there could be numerous connections\nfor payload proxies like SOCKS but we should treat it as a\nsingle tunnel."}, {"field": "id", "type": "conn_id", "description": "The tunnel \u201cconnection\u201d 4-tuple of endpoint addresses/ports.\nFor an IP tunnel, the ports will be 0."}, {"field": "tunnel_type", "type": "Tunnel::Type", "description": ""}, {"field": "action", "type": "Tunnel::Action", "description": ""}], "file": "tunnel.log", "pattern": {"pattern": "%{NUMBER:ts}\\t%{NOTSPACE:uid}\\t%{IP:orig_h}\\t%{INT:orig_p}\\t%{IP:resp_h}\\t%{INT:resp_p}\\t%{GREEDYDATA:tunnel_type}\\t%{GREEDYDATA:action}", "name": "BRO_TUNNEL"}, "log_type": "tunnel"}, {"description": "File analysis results", "url": "https://www.bro.org/sphinx/scripts/base/frameworks/files/main.bro.html#type-Files::Info", "fields": [{"field": "ts", "type": "time", "description": "The time when the file was first seen."}, {"field": "fuid", "type": "string", "description": "An identifier associated with a single file."}, {"field": "tx_hosts", "type": "set", "description": "If this file was transferred over a network\nconnection this should show the host or hosts that\nthe data sourced from."}, {"field": "rx_hosts", "type": "set", "description": "If this file was transferred over a network\nconnection this should show the host or hosts that\nthe data traveled to."}, {"field": "conn_uids", "type": "set", "description": "Connection UIDs over which the file was transferred."}, {"field": "source", "type": "string", "description": "An identification of the source of the file data.  E.g. it\nmay be a network protocol over which it was transferred, or a\nlocal file path which was read, or some other input source."}, {"field": "depth", "type": "count", "description": "A value to represent the depth of this file in relation\nto its source.  In SMTP, it is the depth of the MIME\nattachment on the message.  In HTTP, it is the depth of the\nrequest within the TCP connection."}, {"field": "analyzers", "type": "set", "description": "A set of analysis types done during the file analysis."}, {"field": "mime_type", "type": "string", "description": "A mime type provided by the strongest file magic signature\nmatch against the bof_buffer field of fa_file,\nor in the cases where no buffering of the beginning of file\noccurs, an initial guess of the mime type based on the first\ndata seen."}, {"field": "filename", "type": "string", "description": "A filename for the file if one is available from the source\nfor the file.  These will frequently come from\n\u201cContent-Disposition\u201d headers in network protocols."}, {"field": "duration", "type": "interval", "description": "The duration the file was analyzed for."}, {"field": "local_orig", "type": "bool", "description": "If the source of this file is a network connection, this field\nindicates if the data originated from the local network or not as\ndetermined by the configured Site::local_nets."}, {"field": "is_orig", "type": "bool", "description": "If the source of this file is a network connection, this field\nindicates if the file is being sent by the originator of the\nconnection or the responder."}, {"field": "seen_bytes", "type": "count", "description": "Number of bytes provided to the file analysis engine for the file."}, {"field": "total_bytes", "type": "count", "description": "Total number of bytes that are supposed to comprise the full file."}, {"field": "missing_bytes", "type": "count", "description": "The number of bytes in the file stream that were completely missed\nduring the process of analysis e.g. due to dropped packets."}, {"field": "overflow_bytes", "type": "count", "description": "The number of bytes in the file stream that were not delivered to\nstream file analyzers.  This could be overlapping bytes or\nbytes that couldn\u2019t be reassembled."}, {"field": "timedout", "type": "bool", "description": "Whether the file analysis timed out at least once for the file."}, {"field": "parent_fuid", "type": "string", "description": "Identifier associated with a container file from which this one was\nextracted as part of the file analysis."}, {"field": "md5", "type": "string", "description": "(present if base/files/hash/main.bro is loaded)"}, {"field": "sha1", "type": "string", "description": "(present if base/files/hash/main.bro is loaded)"}, {"field": "sha256", "type": "string", "description": "(present if base/files/hash/main.bro is loaded)"}, {"field": "x509.ts", "type": "time", "description": "Current timestamp."}, {"field": "x509.id", "type": "string", "description": "File id of this certificate."}, {"field": "x509.certificate", "type": "X509::Certificate", "description": "Basic information about the certificate."}, {"field": "x509.handle", "type": "opaque", "description": "The opaque wrapping the certificate. Mainly used\nfor the verify operations."}, {"field": "x509.extensions", "type": "vector", "description": "All extensions that were encountered in the certificate."}, {"field": "x509.san", "type": "X509::SubjectAlternativeName", "description": "Subject alternative name extension of the certificate."}, {"field": "x509.basic_constraints", "type": "X509::BasicConstraints", "description": "Basic constraints extension of the certificate."}, {"field": "x509.logcert", "type": "bool", "description": "(present if policy/protocols/ssl/log-hostcerts-only.bro is loaded)"}, {"field": "extracted", "type": "string", "description": "(present if base/files/extract/main.bro is loaded)"}, {"field": "entropy", "type": "double", "description": "(present if policy/frameworks/files/entropy-test-all-files.bro is loaded)"}], "file": "files.log", "pattern": {"pattern": "%{NUMBER:ts}\\t%{NOTSPACE:fuid}\\t%{GREEDYDATA:tx_hosts}\\t%{GREEDYDATA:rx_hosts}\\t%{NOTSPACE:conn_uids}\\t%{GREEDYDATA:source}\\t%{INT:depth}\\t%{GREEDYDATA:analyzers}\\t%{GREEDYDATA:mime_type}\\t%{GREEDYDATA:filename}\\t%{GREEDYDATA:duration}\\t%{GREEDYDATA:local_orig}\\t%{GREEDYDATA:is_orig}\\t%{INT:seen_bytes}\\t%{INT:total_bytes}\\t%{INT:missing_bytes}\\t%{INT:overflow_bytes}\\t%{GREEDYDATA:timedout}\\t%{NOTSPACE:parent_fuid}\\t%{GREEDYDATA:md5}\\t%{GREEDYDATA:sha1}\\t%{GREEDYDATA:sha256}\\t%{NUMBER:x509.ts}\\t%{GREEDYDATA:x509.id}\\t%{GREEDYDATA:x509.certificate}\\t%{GREEDYDATA:x509.handle}\\t%{GREEDYDATA:x509.extensions}\\t%{GREEDYDATA:x509.san}\\t%{GREEDYDATA:x509.basic_constraints}\\t%{GREEDYDATA:x509.logcert}\\t%{GREEDYDATA:extracted}\\t%{GREEDYDATA:entropy}", "name": "BRO_FILES"}, "log_type": "files"}, {"description": "Portable Executable (PE)", "url": "https://www.bro.org/sphinx/scripts/base/files/pe/main.bro.html#type-PE::Info", "fields": [{"field": "ts", "type": "time", "description": "Current timestamp."}, {"field": "id", "type": "string", "description": "File id of this portable executable file."}, {"field": "machine", "type": "string", "description": "The target machine that the file was compiled for."}, {"field": "compile_ts", "type": "time", "description": "The time that the file was created at."}, {"field": "os", "type": "string", "description": "The required operating system."}, {"field": "subsystem", "type": "string", "description": "The subsystem that is required to run this file."}, {"field": "is_exe", "type": "bool", "description": "Is the file an executable, or just an object file?"}, {"field": "is_64bit", "type": "bool", "description": "Is the file a 64-bit executable?"}, {"field": "uses_aslr", "type": "bool", "description": "Does the file support Address Space Layout Randomization?"}, {"field": "uses_dep", "type": "bool", "description": "Does the file support Data Execution Prevention?"}, {"field": "uses_code_integrity", "type": "bool", "description": "Does the file enforce code integrity checks?"}, {"field": "uses_seh", "type": "bool", "description": "Does the file use structured exception handing?"}, {"field": "has_import_table", "type": "bool", "description": "Does the file have an import table?"}, {"field": "has_export_table", "type": "bool", "description": "Does the file have an export table?"}, {"field": "has_cert_table", "type": "bool", "description": "Does the file have an attribute certificate table?"}, {"field": "has_debug_data", "type": "bool", "description": "Does the file have a debug table?"}, {"field": "section_names", "type": "vector", "description": "The names of the sections, in order."}], "file": "pe.log", "pattern": {"pattern": "%{NUMBER:ts}\\t%{IP:orig_h}\\t%{INT:orig_p}\\t%{IP:resp_h}\\t%{INT:resp_p}\\t%{GREEDYDATA:machine}\\t%{NUMBER:compile_ts}\\t%{GREEDYDATA:os}\\t%{GREEDYDATA:subsystem}\\t%{GREEDYDATA:is_exe}\\t%{GREEDYDATA:is_64bit}\\t%{GREEDYDATA:uses_aslr}\\t%{GREEDYDATA:uses_dep}\\t%{GREEDYDATA:uses_code_integrity}\\t%{GREEDYDATA:uses_seh}\\t%{GREEDYDATA:has_import_table}\\t%{GREEDYDATA:has_export_table}\\t%{GREEDYDATA:has_cert_table}\\t%{GREEDYDATA:has_debug_data}\\t%{GREEDYDATA:section_names}", "name": "BRO_PE"}, "log_type": "pe"}, {"description": "X.509 certificate info", "url": "https://www.bro.org/sphinx/scripts/base/files/x509/main.bro.html#type-X509::Info", "fields": [{"field": "ts", "type": "time", "description": "Current timestamp."}, {"field": "id", "type": "string", "description": "File id of this certificate."}, {"field": "certificate.version", "type": "count", "description": "Version number."}, {"field": "certificate.serial", "type": "string", "description": "Serial number."}, {"field": "certificate.subject", "type": "string", "description": "Subject."}, {"field": "certificate.issuer", "type": "string", "description": "Issuer."}, {"field": "certificate.cn", "type": "string", "description": "Last (most specific) common name."}, {"field": "certificate.not_valid_before", "type": "time", "description": "Timestamp before when certificate is not valid."}, {"field": "certificate.not_valid_after", "type": "time", "description": "Timestamp after when certificate is not valid."}, {"field": "certificate.key_alg", "type": "string", "description": "Name of the key algorithm"}, {"field": "certificate.sig_alg", "type": "string", "description": "Name of the signature algorithm"}, {"field": "certificate.key_type", "type": "string", "description": "Key type, if key parseable by openssl (either rsa, dsa or ec)"}, {"field": "certificate.key_length", "type": "count", "description": "Key length in bits"}, {"field": "certificate.exponent", "type": "string", "description": "Exponent, if RSA-certificate"}, {"field": "certificate.curve", "type": "string", "description": "Curve, if EC-certificate"}, {"field": "handle", "type": "opaque", "description": "The opaque wrapping the certificate. Mainly used\nfor the verify operations."}, {"field": "extensions", "type": "vector", "description": "All extensions that were encountered in the certificate."}, {"field": "san.dns", "type": "string_vec", "description": "List of DNS entries in SAN"}, {"field": "san.uri", "type": "string_vec", "description": "List of URI entries in SAN"}, {"field": "san.email", "type": "string_vec", "description": "List of email entries in SAN"}, {"field": "san.ip", "type": "addr_vec", "description": "List of IP entries in SAN"}, {"field": "san.other_fields", "type": "bool", "description": "True if the certificate contained other, not recognized or parsed name fields"}, {"field": "basic_constraints.ca", "type": "bool", "description": "CA flag set?"}, {"field": "basic_constraints.path_len", "type": "count", "description": "Maximum path length"}, {"field": "logcert", "type": "bool", "description": "(present if policy/protocols/ssl/log-hostcerts-only.bro is loaded)"}], "file": "x509.log", "pattern": {"pattern": "%{NUMBER:ts}\\t%{IP:orig_h}\\t%{INT:orig_p}\\t%{IP:resp_h}\\t%{INT:resp_p}\\t%{INT:certificate.version}\\t%{GREEDYDATA:certificate.serial}\\t%{GREEDYDATA:certificate.subject}\\t%{GREEDYDATA:certificate.issuer}\\t%{GREEDYDATA:certificate.cn}\\t%{NUMBER:certificate.not_valid_before}\\t%{NUMBER:certificate.not_valid_after}\\t%{GREEDYDATA:certificate.key_alg}\\t%{GREEDYDATA:certificate.sig_alg}\\t%{GREEDYDATA:certificate.key_type}\\t%{INT:certificate.key_length}\\t%{GREEDYDATA:certificate.exponent}\\t%{GREEDYDATA:certificate.curve}\\t%{GREEDYDATA:handle}\\t%{GREEDYDATA:extensions}\\t%{GREEDYDATA:san.dns}\\t%{GREEDYDATA:san.uri}\\t%{GREEDYDATA:san.email}\\t%{GREEDYDATA:san.ip}\\t%{GREEDYDATA:san.other_fields}\\t%{GREEDYDATA:basic_constraints.ca}\\t%{INT:basic_constraints.path_len}\\t%{GREEDYDATA:logcert}", "name": "BRO_X509"}, "log_type": "x509"}, {"description": "NetControl actions", "url": "https://www.bro.org/sphinx/scripts/base/frameworks/netcontrol/main.bro.html#type-NetControl::Info", "fields": [{"field": "ts", "type": "time", "description": "Time at which the recorded activity occurred."}, {"field": "rule_id", "type": "string", "description": "ID of the rule; unique during each Bro run."}, {"field": "category", "type": "NetControl::InfoCategory", "description": ""}, {"field": "cmd", "type": "string", "description": "The command the log entry is about."}, {"field": "state", "type": "NetControl::InfoState", "description": ""}, {"field": "action", "type": "string", "description": "String describing an action the entry is about."}, {"field": "target", "type": "NetControl::TargetType", "description": ""}, {"field": "entity_type", "type": "string", "description": "Type of the entity the log entry is about."}, {"field": "entity", "type": "string", "description": "String describing the entity the log entry is about."}, {"field": "mod", "type": "string", "description": "String describing the optional modification of the entry (e.h. redirect)"}, {"field": "msg", "type": "string", "description": "String with an additional message."}, {"field": "priority", "type": "int", "description": "Number describing the priority of the log entry."}, {"field": "expire", "type": "interval", "description": "Expiry time of the log entry."}, {"field": "location", "type": "string", "description": "Location where the underlying action was triggered."}, {"field": "plugin", "type": "string", "description": "Plugin triggering the log entry."}], "file": "netcontrol.log", "pattern": {"pattern": "%{NUMBER:ts}\\t%{GREEDYDATA:rule_id}\\t%{GREEDYDATA:category}\\t%{GREEDYDATA:cmd}\\t%{GREEDYDATA:state}\\t%{GREEDYDATA:action}\\t%{GREEDYDATA:target}\\t%{GREEDYDATA:entity_type}\\t%{GREEDYDATA:entity}\\t%{GREEDYDATA:mod}\\t%{GREEDYDATA:msg}\\t%{INT:priority}\\t%{GREEDYDATA:expire}\\t%{GREEDYDATA:location}\\t%{GREEDYDATA:plugin}", "name": "BRO_NETCONTROL"}, "log_type": "netcontrol"}, {"description": "NetControl actions", "url": "https://www.bro.org/sphinx/scripts/base/frameworks/netcontrol/drop.bro.html#type-NetControl::DropInfo", "fields": [{"field": "ts", "type": "time", "description": "Time at which the recorded activity occurred."}, {"field": "rule_id", "type": "string", "description": "ID of the rule; unique during each Bro run."}, {"field": "orig_h", "type": "addr", "description": "The originator\u2019s IP address."}, {"field": "orig_p", "type": "port", "description": "The originator\u2019s port number."}, {"field": "resp_h", "type": "addr", "description": "The responder\u2019s IP address."}, {"field": "resp_p", "type": "port", "description": "The responder\u2019s port number."}, {"field": "expire", "type": "interval", "description": "Expiry time of the shunt."}, {"field": "location", "type": "string", "description": "Location where the underlying action was triggered."}], "file": "netcontrol_drop.log", "pattern": {"pattern": "%{NUMBER:ts}\\t%{GREEDYDATA:rule_id}\\t%{IP:orig_h}\\t%{INT:orig_p}\\t%{IP:resp_h}\\t%{INT:resp_p}\\t%{GREEDYDATA:expire}\\t%{GREEDYDATA:location}", "name": "BRO_NETCONTROL_DROP"}, "log_type": "netcontrol_drop"}, {"description": "NetControl shunt actions", "url": "https://www.bro.org/sphinx/scripts/base/frameworks/netcontrol/shunt.bro.html#type-NetControl::ShuntInfo", "fields": [{"field": "ts", "type": "time", "description": "Time at which the recorded activity occurred."}, {"field": "rule_id", "type": "string", "description": "ID of the rule; unique during each Bro run."}, {"field": "f", "type": "flow_id", "description": "Flow ID of the shunted flow."}, {"field": "expire", "type": "interval", "description": "Expiry time of the shunt."}, {"field": "location", "type": "string", "description": "Location where the underlying action was triggered."}], "file": "netcontrol_shunt.log", "pattern": {"pattern": "%{NUMBER:ts}\\t%{GREEDYDATA:rule_id}\\t%{GREEDYDATA:f}\\t%{GREEDYDATA:expire}\\t%{GREEDYDATA:location}", "name": "BRO_NETCONTROL_SHUNT"}, "log_type": "netcontrol_shunt"}, {"description": "NetControl catch and release actions", "url": "https://www.bro.org/sphinx/scripts/base/frameworks/netcontrol/catch-and-release.bro.html#type-NetControl::CatchReleaseInfo", "fields": [{"field": "ts", "type": "time", "description": "The absolute time indicating when the action for this log-line occured."}, {"field": "rule_id", "type": "string", "description": "The rule id that this log line refers to."}, {"field": "ip", "type": "addr", "description": "The IP address that this line refers to."}, {"field": "action", "type": "NetControl::CatchReleaseActions", "description": ""}, {"field": "block_interval", "type": "interval", "description": "The current block_interaval (for how long the address is blocked)."}, {"field": "watch_interval", "type": "interval", "description": "The current watch_interval (for how long the address will be watched and re-block if it reappears)."}, {"field": "blocked_until", "type": "time", "description": "The absolute time until which the address is blocked."}, {"field": "watched_until", "type": "time", "description": "The absolute time until which the address will be monitored."}, {"field": "num_blocked", "type": "count", "description": "Number of times that this address was blocked in the current cycle."}, {"field": "location", "type": "string", "description": "The user specified location string."}, {"field": "message", "type": "string", "description": "Additional informational string by the catch and release framework about this log-line."}], "file": "netcontrol_catch_release.log", "pattern": {"pattern": "%{NUMBER:ts}\\t%{GREEDYDATA:rule_id}\\t%{IP:ip}\\t%{GREEDYDATA:action}\\t%{GREEDYDATA:block_interval}\\t%{GREEDYDATA:watch_interval}\\t%{NUMBER:blocked_until}\\t%{NUMBER:watched_until}\\t%{INT:num_blocked}\\t%{GREEDYDATA:location}\\t%{GREEDYDATA:message}", "name": "BRO_NETCONTROL_CATCH_RELEASE"}, "log_type": "netcontrol_catch_release"}, {"description": "OpenFlow debug log", "url": "https://www.bro.org/sphinx/scripts/base/frameworks/openflow/plugins/log.bro.html#type-OpenFlow::Info", "fields": [{"field": "ts", "type": "time", "description": "Network time."}, {"field": "dpid", "type": "count", "description": "OpenFlow switch datapath id."}, {"field": "match.in_port", "type": "count", "description": ""}, {"field": "match.dl_src", "type": "string", "description": ""}, {"field": "match.dl_dst", "type": "string", "description": ""}, {"field": "match.dl_vlan", "type": "count", "description": ""}, {"field": "match.dl_vlan_pcp", "type": "count", "description": ""}, {"field": "match.dl_type", "type": "count", "description": ""}, {"field": "match.nw_tos", "type": "count", "description": ""}, {"field": "match.nw_proto", "type": "count", "description": ""}, {"field": "match.nw_src", "type": "subnet", "description": ""}, {"field": "match.nw_dst", "type": "subnet", "description": ""}, {"field": "match.tp_src", "type": "count", "description": ""}, {"field": "match.tp_dst", "type": "count", "description": ""}, {"field": "flow_mod.cookie", "type": "count", "description": "Opaque controller-issued identifier."}, {"field": "flow_mod.table_id", "type": "count", "description": "Table to put the flow in. OFPTT_ALL can be used for delete,\nto delete flows from all matching tables."}, {"field": "flow_mod.command", "type": "OpenFlow::ofp_flow_mod_command", "description": "One of OFPFC_*."}, {"field": "flow_mod.idle_timeout", "type": "count", "description": "Idle time before discarding (seconds)."}, {"field": "flow_mod.hard_timeout", "type": "count", "description": "Max time before discarding (seconds)."}, {"field": "flow_mod.priority", "type": "count", "description": "Priority level of flow entry."}, {"field": "flow_mod.out_port", "type": "count", "description": "For OFPFC_DELETE* commands, require matching entried to include\nthis as an output port/group. OFPP_ANY/OFPG_ANY means no restrictions."}], "file": "openflow.log", "pattern": {"pattern": "%{NUMBER:ts}\\t%{INT:dpid}\\t%{INT:match.in_port}\\t%{GREEDYDATA:match.dl_src}\\t%{GREEDYDATA:match.dl_dst}\\t%{INT:match.dl_vlan}\\t%{INT:match.dl_vlan_pcp}\\t%{INT:match.dl_type}\\t%{INT:match.nw_tos}\\t%{INT:match.nw_proto}\\t%{GREEDYDATA:match.nw_src}\\t%{GREEDYDATA:match.nw_dst}\\t%{INT:match.tp_src}\\t%{INT:match.tp_dst}\\t%{INT:flow_mod.cookie}\\t%{INT:flow_mod.table_id}\\t%{GREEDYDATA:flow_mod.command}\\t%{INT:flow_mod.idle_timeout}\\t%{INT:flow_mod.hard_timeout}\\t%{INT:flow_mod.priority}\\t%{INT:flow_mod.out_port}", "name": "BRO_OPENFLOW"}, "log_type": "openflow"}, {"description": "Intelligence data matches", "url": "https://www.bro.org/sphinx/scripts/base/frameworks/intel/main.bro.html#type-Intel::Info", "fields": [{"field": "ts", "type": "time", "description": "Timestamp when the data was discovered."}, {"field": "uid", "type": "string", "description": "If a connection was associated with this intelligence hit,\nthis is the uid for the connection"}, {"field": "id", "type": "conn_id", "description": "If a connection was associated with this intelligence hit,\nthis is the conn_id for the connection."}, {"field": "seen.indicator", "type": "string", "description": "The string if the data is about a string."}, {"field": "seen.indicator_type", "type": "Intel::Type", "description": "The type of data that the indicator represents."}, {"field": "seen.host", "type": "addr", "description": "If the indicator type was Intel::ADDR, then this\nfield will be present."}, {"field": "seen.where", "type": "Intel::Where", "description": "Where the data was discovered."}, {"field": "seen.node", "type": "string", "description": "The name of the node where the match was discovered."}, {"field": "seen.conn", "type": "connection", "description": "If the data was discovered within a connection, the\nconnection record should go here to give context to the data."}, {"field": "seen.uid", "type": "string", "description": "If the data was discovered within a connection, the\nconnection uid should go here to give context to the data.\nIf the conn field is provided, this will be automatically\nfilled out."}, {"field": "seen.f", "type": "fa_file", "description": "(present if base/frameworks/intel/files.bro is loaded)"}, {"field": "seen.fuid", "type": "string", "description": "(present if base/frameworks/intel/files.bro is loaded)"}, {"field": "matched", "type": "Intel::TypeSet", "description": ""}, {"field": "sources", "type": "set", "description": "Sources which supplied data that resulted in this match."}, {"field": "fuid", "type": "string", "description": "(present if base/frameworks/intel/files.bro is loaded)"}, {"field": "file_mime_type", "type": "string", "description": "(present if base/frameworks/intel/files.bro is loaded)"}, {"field": "file_desc", "type": "string", "description": "(present if base/frameworks/intel/files.bro is loaded)"}], "file": "intel.log", "pattern": {"pattern": "%{NUMBER:ts}\\t%{NOTSPACE:uid}\\t%{IP:orig_h}\\t%{INT:orig_p}\\t%{IP:resp_h}\\t%{INT:resp_p}\\t%{GREEDYDATA:seen.indicator}\\t%{GREEDYDATA:seen.indicator_type}\\t%{IP:seen.host}\\t%{GREEDYDATA:seen.where}\\t%{GREEDYDATA:seen.node}\\t%{GREEDYDATA:seen.conn}\\t%{NOTSPACE:seen.uid}\\t%{GREEDYDATA:seen.f}\\t%{NOTSPACE:seen.fuid}\\t%{GREEDYDATA:matched}\\t%{GREEDYDATA:sources}\\t%{NOTSPACE:fuid}\\t%{GREEDYDATA:file_mime_type}\\t%{GREEDYDATA:file_desc}", "name": "BRO_INTEL"}, "log_type": "intel"}, {"description": "Bro notices", "url": "https://www.bro.org/sphinx/scripts/base/frameworks/notice/main.bro.html#type-Notice::Info", "fields": [{"field": "ts", "type": "time", "description": "An absolute time indicating when the notice occurred,\ndefaults to the current network time."}, {"field": "uid", "type": "string", "description": "A connection UID which uniquely identifies the endpoints\nconcerned with the notice."}, {"field": "id", "type": "conn_id", "description": "A connection 4-tuple identifying the endpoints concerned\nwith the notice."}, {"field": "conn", "type": "connection", "description": "A shorthand way of giving the uid and id to a notice.  The\nreference to the actual connection will be deleted after\napplying the notice policy."}, {"field": "iconn", "type": "icmp_conn", "description": "A shorthand way of giving the uid and id to a notice.  The\nreference to the actual connection will be deleted after\napplying the notice policy."}, {"field": "f", "type": "fa_file", "description": "A file record if the notice is related to a file.  The\nreference to the actual fa_file record will be deleted after\napplying the notice policy."}, {"field": "fuid", "type": "string", "description": "A file unique ID if this notice is related to a file.  If\nthe f field is provided, this will be automatically filled\nout."}, {"field": "file_mime_type", "type": "string", "description": "A mime type if the notice is related to a file.  If the f\nfield is provided, this will be automatically filled out."}, {"field": "file_desc", "type": "string", "description": "Frequently files can be \u201cdescribed\u201d to give a bit more\ncontext.  This field will typically be automatically filled\nout from an fa_file record.  For example, if a notice was\nrelated to a file over HTTP, the URL of the request would\nbe shown."}, {"field": "proto", "type": "transport_proto", "description": "The transport protocol. Filled automatically when either\nconn, iconn or p is specified."}, {"field": "note", "type": "Notice::Type", "description": ""}, {"field": "msg", "type": "string", "description": "The human readable message for the notice."}, {"field": "sub", "type": "string", "description": "The human readable sub-message."}, {"field": "src", "type": "addr", "description": "Source address, if we don\u2019t have a conn_id."}, {"field": "dst", "type": "addr", "description": "Destination address."}, {"field": "p", "type": "port", "description": "Associated port, if we don\u2019t have a conn_id."}, {"field": "n", "type": "count", "description": "Associated count, or perhaps a status code."}, {"field": "src_peer", "type": "event_peer", "description": "Peer that raised this notice."}, {"field": "peer_descr", "type": "string", "description": "Textual description for the peer that raised this notice."}, {"field": "actions", "type": "Notice::ActionSet", "description": ""}, {"field": "email_body_sections", "type": "vector", "description": "By adding chunks of text into this element, other scripts\ncan expand on notices that are being emailed.  The normal\nway to add text is to extend the vector by handling the\nNotice::notice event and modifying the notice in\nplace."}, {"field": "email_delay_tokens", "type": "set", "description": "Adding a string \u201ctoken\u201d to this set will cause the notice\nframework\u2019s built-in emailing functionality to delay sending\nthe email until either the token has been removed or the\nemail has been delayed for Notice::max_email_delay."}, {"field": "identifier", "type": "string", "description": "This field is to be provided when a notice is generated for\nthe purpose of deduplicating notices.  The identifier string\nshould be unique for a single instance of the notice.  This\nfield should be filled out in almost all cases when\ngenerating notices to define when a notice is conceptually\na duplicate of a previous notice."}, {"field": "suppress_for", "type": "interval", "description": "This field indicates the length of time that this\nunique notice should be suppressed."}, {"field": "dropped", "type": "bool", "description": "(present if base/frameworks/notice/actions/drop.bro is loaded)"}, {"field": "remote_location", "type": "geo_location", "description": "(present if base/frameworks/notice/actions/add-geodata.bro is loaded)"}], "file": "notice.log", "pattern": {"pattern": "%{NUMBER:ts}\\t%{NOTSPACE:uid}\\t%{IP:orig_h}\\t%{INT:orig_p}\\t%{IP:resp_h}\\t%{INT:resp_p}\\t%{GREEDYDATA:conn}\\t%{GREEDYDATA:iconn}\\t%{GREEDYDATA:f}\\t%{NOTSPACE:fuid}\\t%{GREEDYDATA:file_mime_type}\\t%{GREEDYDATA:file_desc}\\t%{WORD:proto}\\t%{GREEDYDATA:note}\\t%{GREEDYDATA:msg}\\t%{GREEDYDATA:sub}\\t%{IP:src}\\t%{IP:dst}\\t%{INT:p}\\t%{INT:n}\\t%{GREEDYDATA:src_peer}\\t%{GREEDYDATA:peer_descr}\\t%{GREEDYDATA:actions}\\t%{GREEDYDATA:email_body_sections}\\t%{GREEDYDATA:email_delay_tokens}\\t%{GREEDYDATA:identifier}\\t%{GREEDYDATA:suppress_for}\\t%{GREEDYDATA:dropped}\\t%{GREEDYDATA:remote_location}", "name": "BRO_NOTICE"}, "log_type": "notice"}, {"fields": [], "log_type": "notice_alarm", "file": "notice_alarm.log", "description": "The alarm stream"}, {"description": "Signature matches", "url": "https://www.bro.org/sphinx/scripts/base/frameworks/signatures/main.bro.html#type-Signatures::Info", "fields": [{"field": "ts", "type": "time", "description": "The network time at which a signature matching type of event\nto be logged has occurred."}, {"field": "uid", "type": "string", "description": "A unique identifier of the connection which triggered the\nsignature match event."}, {"field": "src_addr", "type": "addr", "description": "The host which triggered the signature match event."}, {"field": "src_port", "type": "port", "description": "The host port on which the signature-matching activity\noccurred."}, {"field": "dst_addr", "type": "addr", "description": "The destination host which was sent the payload that\ntriggered the signature match."}, {"field": "dst_port", "type": "port", "description": "The destination host port which was sent the payload that\ntriggered the signature match."}, {"field": "note", "type": "Notice::Type", "description": ""}, {"field": "sig_id", "type": "string", "description": "The name of the signature that matched."}, {"field": "event_msg", "type": "string", "description": "A more descriptive message of the signature-matching event."}, {"field": "sub_msg", "type": "string", "description": "Extracted payload data or extra message."}, {"field": "sig_count", "type": "count", "description": "Number of sigs, usually from summary count."}, {"field": "host_count", "type": "count", "description": "Number of hosts, from a summary count."}], "file": "signatures.log", "pattern": {"pattern": "%{NUMBER:ts}\\t%{NOTSPACE:uid}\\t%{IP:src_addr}\\t%{INT:src_port}\\t%{IP:dst_addr}\\t%{INT:dst_port}\\t%{GREEDYDATA:note}\\t%{GREEDYDATA:sig_id}\\t%{GREEDYDATA:event_msg}\\t%{GREEDYDATA:sub_msg}\\t%{INT:sig_count}\\t%{INT:host_count}", "name": "BRO_SIGNATURES"}, "log_type": "signatures"}, {"description": "Traceroute detection", "url": "https://www.bro.org/sphinx/scripts/policy/misc/detect-traceroute/main.bro.html#type-Traceroute::Info", "fields": [{"field": "ts", "type": "time", "description": "Timestamp"}, {"field": "src", "type": "addr", "description": "Address initiating the traceroute."}, {"field": "dst", "type": "addr", "description": "Destination address of the traceroute."}, {"field": "proto", "type": "string", "description": "Protocol used for the traceroute."}], "file": "traceroute.log", "pattern": {"pattern": "%{NUMBER:ts}\\t%{IP:src}\\t%{IP:dst}\\t%{GREEDYDATA:proto}", "name": "BRO_TRACEROUTE"}, "log_type": "traceroute"}, {"description": "SSL certificates", "url": "https://www.bro.org/sphinx/scripts/policy/protocols/ssl/known-certs.bro.html#type-Known::CertsInfo", "fields": [{"field": "ts", "type": "time", "description": "The timestamp when the certificate was detected."}, {"field": "host", "type": "addr", "description": "The address that offered the certificate."}, {"field": "port_num", "type": "port", "description": "If the certificate was handed out by a server, this is the\nport that the server was listening on."}, {"field": "subject", "type": "string", "description": "Certificate subject."}, {"field": "issuer_subject", "type": "string", "description": "Certificate issuer subject."}, {"field": "serial", "type": "string", "description": "Serial number for the certificate."}], "file": "known_certs.log", "pattern": {"pattern": "%{NUMBER:ts}\\t%{IP:host}\\t%{INT:port_num}\\t%{GREEDYDATA:subject}\\t%{GREEDYDATA:issuer_subject}\\t%{GREEDYDATA:serial}", "name": "BRO_KNOWN_CERTS"}, "log_type": "known_certs"}, {"description": "MAC addresses of devices on the\nnetwork", "url": "https://www.bro.org/sphinx/scripts/policy/misc/known-devices.bro.html#type-Known::DevicesInfo", "fields": [{"field": "ts", "type": "time", "description": "The timestamp at which the host was detected."}, {"field": "mac", "type": "string", "description": "The MAC address that was detected."}, {"field": "dhcp_host_name", "type": "string", "description": "(present if policy/protocols/dhcp/known-devices-and-hostnames.bro is loaded)"}], "file": "known_devices.log", "pattern": {"pattern": "%{NUMBER:ts}\\t%{GREEDYDATA:mac}\\t%{GREEDYDATA:dhcp_host_name}", "name": "BRO_KNOWN_DEVICES"}, "log_type": "known_devices"}, {"description": "Hosts that have completed TCP\nhandshakes", "url": "https://www.bro.org/sphinx/scripts/policy/protocols/conn/known-hosts.bro.html#type-Known::HostsInfo", "fields": [{"field": "ts", "type": "time", "description": "The timestamp at which the host was detected."}, {"field": "host", "type": "addr", "description": "The address that was detected originating or responding to a\nTCP connection."}], "file": "known_hosts.log", "pattern": {"pattern": "%{NUMBER:ts}\\t%{IP:host}", "name": "BRO_KNOWN_HOSTS"}, "log_type": "known_hosts"}, {"description": "Modbus masters and slaves", "url": "https://www.bro.org/sphinx/scripts/policy/protocols/modbus/known-masters-slaves.bro.html#type-Known::ModbusInfo", "fields": [{"field": "ts", "type": "time", "description": "The time the device was discovered."}, {"field": "host", "type": "addr", "description": "The IP address of the host."}, {"field": "device_type", "type": "Known::ModbusDeviceType", "description": ""}], "file": "known_modbus.log", "pattern": {"pattern": "%{NUMBER:ts}\\t%{IP:host}\\t%{GREEDYDATA:device_type}", "name": "BRO_KNOWN_MODBUS"}, "log_type": "known_modbus"}, {"description": "Services running on hosts", "url": "https://www.bro.org/sphinx/scripts/policy/protocols/conn/known-services.bro.html#type-Known::ServicesInfo", "fields": [{"field": "ts", "type": "time", "description": "The time at which the service was detected."}, {"field": "host", "type": "addr", "description": "The host address on which the service is running."}, {"field": "port_num", "type": "port", "description": "The port number on which the service is running."}, {"field": "port_proto", "type": "transport_proto", "description": "The transport-layer protocol which the service uses."}, {"field": "service", "type": "set", "description": "A set of protocols that match the service\u2019s connection payloads."}], "file": "known_services.log", "pattern": {"pattern": "%{NUMBER:ts}\\t%{IP:host}\\t%{INT:port_num}\\t%{WORD:port_proto}\\t%{GREEDYDATA:service}", "name": "BRO_KNOWN_SERVICES"}, "log_type": "known_services"}, {"description": "Software being used on the network", "url": "https://www.bro.org/sphinx/scripts/base/frameworks/software/main.bro.html#type-Software::Info", "fields": [{"field": "ts", "type": "time", "description": "The time at which the software was detected."}, {"field": "host", "type": "addr", "description": "The IP address detected running the software."}, {"field": "host_p", "type": "port", "description": "The port on which the software is running. Only sensible for\nserver software."}, {"field": "software_type", "type": "Software::Type", "description": ""}, {"field": "name", "type": "string", "description": "Name of the software (e.g. Apache)."}, {"field": "version.major", "type": "count", "description": "Major version number."}, {"field": "version.minor", "type": "count", "description": "Minor version number."}, {"field": "version.minor2", "type": "count", "description": "Minor subversion number."}, {"field": "version.minor3", "type": "count", "description": "Minor updates number."}, {"field": "version.addl", "type": "string", "description": "Additional version string (e.g. \u201cbeta42\u201d)."}, {"field": "unparsed_version", "type": "string", "description": "The full unparsed version string found because the version\nparsing doesn\u2019t always work reliably in all cases and this\nacts as a fallback in the logs."}, {"field": "force_log", "type": "bool", "description": "This can indicate that this software being detected should\ndefinitely be sent onward to the logging framework.  By\ndefault, only software that is \u201cinteresting\u201d due to a change\nin version or it being currently unknown is sent to the\nlogging framework.  This can be set to T to force the record\nto be sent to the logging framework if some amount of this\ntracking needs to happen in a specific way to the software."}, {"field": "url", "type": "string", "description": "(present if policy/protocols/http/detect-webapps.bro is loaded)"}], "file": "software.log", "pattern": {"pattern": "%{NUMBER:ts}\\t%{IP:host}\\t%{INT:host_p}\\t%{GREEDYDATA:software_type}\\t%{GREEDYDATA:name}\\t%{INT:version.major}\\t%{INT:version.minor}\\t%{INT:version.minor2}\\t%{INT:version.minor3}\\t%{GREEDYDATA:version.addl}\\t%{GREEDYDATA:unparsed_version}\\t%{GREEDYDATA:force_log}\\t%{GREEDYDATA:url}", "name": "BRO_SOFTWARE"}, "log_type": "software"}, {"description": "Alerts received from Barnyard2", "url": "https://www.bro.org/sphinx/scripts/policy/integration/barnyard2/main.bro.html#type-Barnyard2::Info", "fields": [{"field": "ts", "type": "time", "description": ""}, {"field": "pid", "type": "Barnyard2::PacketID", "description": ""}, {"field": "alert", "type": "Barnyard2::AlertData", "description": ""}], "file": "barnyard2.log", "pattern": {"pattern": "%{NUMBER:ts}\\t%{GREEDYDATA:pid}\\t%{GREEDYDATA:alert}", "name": "BRO_BARNYARD2"}, "log_type": "barnyard2"}, {"description": "Dynamic protocol detection failures", "url": "https://www.bro.org/sphinx/scripts/base/frameworks/dpd/main.bro.html#type-DPD::Info", "fields": [{"field": "ts", "type": "time", "description": "Timestamp for when protocol analysis failed."}, {"field": "uid", "type": "string", "description": "Connection unique ID."}, {"field": "id", "type": "conn_id", "description": "Connection ID containing the 4-tuple which identifies endpoints."}, {"field": "proto", "type": "transport_proto", "description": "Transport protocol for the violation."}, {"field": "analyzer", "type": "string", "description": "The analyzer that generated the violation."}, {"field": "failure_reason", "type": "string", "description": "The textual reason for the analysis failure."}, {"field": "disabled_aids", "type": "set", "description": "Disabled analyzer IDs.  This is only for internal tracking\nso as to not attempt to disable analyzers multiple times."}, {"field": "packet_segment", "type": "string", "description": "(present if policy/frameworks/dpd/packet-segment-logging.bro is loaded)"}], "file": "dpd.log", "pattern": {"pattern": "%{NUMBER:ts}\\t%{NOTSPACE:uid}\\t%{IP:orig_h}\\t%{INT:orig_p}\\t%{IP:resp_h}\\t%{INT:resp_p}\\t%{WORD:proto}\\t%{GREEDYDATA:analyzer}\\t%{GREEDYDATA:failure_reason}\\t%{GREEDYDATA:disabled_aids}\\t%{GREEDYDATA:packet_segment}", "name": "BRO_DPD"}, "log_type": "dpd"}, {"description": "Interprets Snort\u2019s unified output", "url": "https://www.bro.org/sphinx/scripts/base/files/unified2/main.bro.html#type-Unified2::Info", "fields": [{"field": "ts", "type": "time", "description": "Timestamp attached to the alert."}, {"field": "id.src_ip", "type": "addr", "description": ""}, {"field": "id.src_p", "type": "port", "description": ""}, {"field": "id.dst_ip", "type": "addr", "description": ""}, {"field": "id.dst_p", "type": "port", "description": ""}, {"field": "sensor_id", "type": "count", "description": "Sensor that originated this event."}, {"field": "signature_id", "type": "count", "description": "Sig id for this generator."}, {"field": "signature", "type": "string", "description": "A string representation of the signature_id field if a sid_msg.map file was loaded."}, {"field": "generator_id", "type": "count", "description": "Which generator generated the alert?"}, {"field": "generator", "type": "string", "description": "A string representation of the generator_id field if a gen_msg.map file was loaded."}, {"field": "signature_revision", "type": "count", "description": "Sig revision for this id."}, {"field": "classification_id", "type": "count", "description": "Event classification."}, {"field": "classification", "type": "string", "description": "Descriptive classification string."}, {"field": "priority_id", "type": "count", "description": "Event priority."}, {"field": "event_id", "type": "count", "description": "Event ID."}, {"field": "packet", "type": "string", "description": "Some of the packet data."}], "file": "unified2.log", "pattern": {"pattern": "%{NUMBER:ts}\\t%{IP:id.src_ip}\\t%{INT:id.src_p}\\t%{IP:id.dst_ip}\\t%{INT:id.dst_p}\\t%{INT:sensor_id}\\t%{INT:signature_id}\\t%{GREEDYDATA:signature}\\t%{INT:generator_id}\\t%{GREEDYDATA:generator}\\t%{INT:signature_revision}\\t%{INT:classification_id}\\t%{GREEDYDATA:classification}\\t%{INT:priority_id}\\t%{INT:event_id}\\t%{GREEDYDATA:packet}", "name": "BRO_UNIFIED2"}, "log_type": "unified2"}, {"description": "Unexpected network-level activity", "url": "https://www.bro.org/sphinx/scripts/base/frameworks/notice/weird.bro.html#type-Weird::Info", "fields": [{"field": "ts", "type": "time", "description": "The time when the weird occurred."}, {"field": "uid", "type": "string", "description": "If a connection is associated with this weird, this will be\nthe connection\u2019s unique ID."}, {"field": "id", "type": "conn_id", "description": "conn_id for the optional connection."}, {"field": "conn", "type": "connection", "description": "A shorthand way of giving the uid and id to a weird."}, {"field": "name", "type": "string", "description": "The name of the weird that occurred."}, {"field": "addl", "type": "string", "description": "Additional information accompanying the weird if any."}, {"field": "notice", "type": "bool", "description": "Indicate if this weird was also turned into a notice."}, {"field": "peer", "type": "string", "description": "The peer that originated this weird.  This is helpful in\ncluster deployments if a particular cluster node is having\ntrouble to help identify which node is having trouble."}, {"field": "identifier", "type": "string", "description": "This field is to be provided when a weird is generated for\nthe purpose of deduplicating weirds. The identifier string\nshould be unique for a single instance of the weird. This field\nis used to define when a weird is conceptually a duplicate of\na previous weird."}], "file": "weird.log", "pattern": {"pattern": "%{NUMBER:ts}\\t%{NOTSPACE:uid}\\t%{IP:orig_h}\\t%{INT:orig_p}\\t%{IP:resp_h}\\t%{INT:resp_p}\\t%{GREEDYDATA:conn}\\t%{GREEDYDATA:name}\\t%{GREEDYDATA:addl}\\t%{GREEDYDATA:notice}\\t%{GREEDYDATA:peer}\\t%{GREEDYDATA:identifier}", "name": "BRO_WEIRD"}, "log_type": "weird"}, {"description": "Packet loss rate", "url": "https://www.bro.org/sphinx/scripts/policy/misc/capture-loss.bro.html#type-CaptureLoss::Info", "fields": [{"field": "ts", "type": "time", "description": "Timestamp for when the measurement occurred."}, {"field": "ts_delta", "type": "interval", "description": "The time delay between this measurement and the last."}, {"field": "peer", "type": "string", "description": "In the event that there are multiple Bro instances logging\nto the same host, this distinguishes each peer with its\nindividual name."}, {"field": "gaps", "type": "count", "description": "Number of missed ACKs from the previous measurement interval."}, {"field": "acks", "type": "count", "description": "Total number of ACKs seen in the previous measurement interval."}, {"field": "percent_lost", "type": "double", "description": "Percentage of ACKs seen where the data being ACKed wasn\u2019t seen."}], "file": "capture_loss.log", "pattern": {"pattern": "%{NUMBER:ts}\\t%{GREEDYDATA:ts_delta}\\t%{GREEDYDATA:peer}\\t%{INT:gaps}\\t%{INT:acks}\\t%{GREEDYDATA:percent_lost}", "name": "BRO_CAPTURE_LOSS"}, "log_type": "capture_loss"}, {"description": "Bro cluster messages", "url": "https://www.bro.org/sphinx/scripts/base/frameworks/cluster/main.bro.html#type-Cluster::Info", "fields": [{"field": "ts", "type": "time", "description": "The time at which a cluster message was generated."}, {"field": "message", "type": "string", "description": "A message indicating information about the cluster\u2019s operation."}], "file": "cluster.log", "pattern": {"pattern": "%{NUMBER:ts}\\t%{GREEDYDATA:message}", "name": "BRO_CLUSTER"}, "log_type": "cluster"}, {"description": "Communication events between Bro or\nBroccoli instances", "url": "https://www.bro.org/sphinx/scripts/base/frameworks/communication/main.bro.html#type-Communication::Info", "fields": [{"field": "ts", "type": "time", "description": "The network time at which a communication event occurred."}, {"field": "peer", "type": "string", "description": "The peer name (if any) with which a communication event is\nconcerned."}, {"field": "src_name", "type": "string", "description": "Where the communication event message originated from, that\nis, either from the scripting layer or inside the Bro process."}, {"field": "connected_peer_desc", "type": "string", "description": "Todo"}, {"field": "connected_peer_addr", "type": "addr", "description": "Todo"}, {"field": "connected_peer_port", "type": "port", "description": "Todo"}, {"field": "level", "type": "string", "description": "The severity of the communication event message."}, {"field": "message", "type": "string", "description": "A message describing the communication event between Bro or\nBroccoli instances."}], "file": "communication.log", "pattern": {"pattern": "%{NUMBER:ts}\\t%{GREEDYDATA:peer}\\t%{GREEDYDATA:src_name}\\t%{GREEDYDATA:connected_peer_desc}\\t%{IP:connected_peer_addr}\\t%{INT:connected_peer_port}\\t%{GREEDYDATA:level}\\t%{GREEDYDATA:message}", "name": "BRO_COMMUNICATION"}, "log_type": "communication"}, {"description": "Shows all scripts loaded by Bro", "url": "https://www.bro.org/sphinx/scripts/policy/misc/loaded-scripts.bro.html#type-LoadedScripts::Info", "fields": [{"field": "name", "type": "string", "description": "Name of the script loaded potentially with spaces included\nbefore the file name to indicate load depth.  The convention\nis two spaces per level of depth."}], "file": "loaded_scripts.log", "pattern": {"pattern": "%{GREEDYDATA:name}", "name": "BRO_LOADED_SCRIPTS"}, "log_type": "loaded_scripts"}, {"description": "List packet filters that were applied", "url": "https://www.bro.org/sphinx/scripts/base/frameworks/packet-filter/main.bro.html#type-PacketFilter::Info", "fields": [{"field": "ts", "type": "time", "description": "The time at which the packet filter installation attempt was made."}, {"field": "node", "type": "string", "description": "This is a string representation of the node that applied this\npacket filter.  It\u2019s mostly useful in the context of\ndynamically changing filters on clusters."}, {"field": "filter", "type": "string", "description": "The packet filter that is being set."}, {"field": "init", "type": "bool", "description": "Indicate if this is the filter set during initialization."}, {"field": "success", "type": "bool", "description": "Indicate if the filter was applied successfully."}], "file": "packet_filter.log", "pattern": {"pattern": "%{NUMBER:ts}\\t%{GREEDYDATA:node}\\t%{GREEDYDATA:filter}\\t%{GREEDYDATA:init}\\t%{GREEDYDATA:success}", "name": "BRO_PACKET_FILTER"}, "log_type": "packet_filter"}, {"fields": [], "log_type": "prof", "file": "prof.log", "description": "Profiling statistics (to create this\nlog, load policy/misc/profiling.bro)"}, {"description": "Internal error/warning/info messages", "url": "https://www.bro.org/sphinx/scripts/base/frameworks/reporter/main.bro.html#type-Reporter::Info", "fields": [{"field": "ts", "type": "time", "description": "The network time at which the reporter event was generated."}, {"field": "level", "type": "Reporter::Level", "description": ""}, {"field": "message", "type": "string", "description": "An info/warning/error message that could have either been\ngenerated from the internal Bro core or at the scripting-layer."}, {"field": "location", "type": "string", "description": "This is the location in a Bro script where the message originated.\nNot all reporter messages will have locations in them though."}], "file": "reporter.log", "pattern": {"pattern": "%{NUMBER:ts}\\t%{GREEDYDATA:level}\\t%{GREEDYDATA:message}\\t%{GREEDYDATA:location}", "name": "BRO_REPORTER"}, "log_type": "reporter"}, {"description": "Memory/event/packet/lag statistics", "url": "https://www.bro.org/sphinx/scripts/policy/misc/stats.bro.html#type-Stats::Info", "fields": [{"field": "ts", "type": "time", "description": "Timestamp for the measurement."}, {"field": "peer", "type": "string", "description": "Peer that generated this log.  Mostly for clusters."}, {"field": "mem", "type": "count", "description": "Amount of memory currently in use in MB."}, {"field": "pkts_proc", "type": "count", "description": "Number of packets processed since the last stats interval."}, {"field": "bytes_recv", "type": "count", "description": "Number of bytes received since the last stats interval if\nreading live traffic."}, {"field": "pkts_dropped", "type": "count", "description": "Number of packets dropped since the last stats interval if\nreading live traffic."}, {"field": "pkts_link", "type": "count", "description": "Number of packets seen on the link since the last stats\ninterval if reading live traffic."}, {"field": "pkt_lag", "type": "interval", "description": "Lag between the wall clock and packet timestamps if reading\nlive traffic."}, {"field": "events_proc", "type": "count", "description": "Number of events processed since the last stats interval."}, {"field": "events_queued", "type": "count", "description": "Number of events that have been queued since the last stats\ninterval."}, {"field": "active_tcp_conns", "type": "count", "description": "TCP connections currently in memory."}, {"field": "active_udp_conns", "type": "count", "description": "UDP connections currently in memory."}, {"field": "active_icmp_conns", "type": "count", "description": "ICMP connections currently in memory."}, {"field": "tcp_conns", "type": "count", "description": "TCP connections seen since last stats interval."}, {"field": "udp_conns", "type": "count", "description": "UDP connections seen since last stats interval."}, {"field": "icmp_conns", "type": "count", "description": "ICMP connections seen since last stats interval."}, {"field": "timers", "type": "count", "description": "Number of timers scheduled since last stats interval."}, {"field": "active_timers", "type": "count", "description": "Current number of scheduled timers."}, {"field": "files", "type": "count", "description": "Number of files seen since last stats interval."}, {"field": "active_files", "type": "count", "description": "Current number of files actively being seen."}, {"field": "dns_requests", "type": "count", "description": "Number of DNS requests seen since last stats interval."}, {"field": "active_dns_requests", "type": "count", "description": "Current number of DNS requests awaiting a reply."}, {"field": "reassem_tcp_size", "type": "count", "description": "Current size of TCP data in reassembly."}, {"field": "reassem_file_size", "type": "count", "description": "Current size of File data in reassembly."}, {"field": "reassem_frag_size", "type": "count", "description": "Current size of packet fragment data in reassembly."}, {"field": "reassem_unknown_size", "type": "count", "description": "Current size of unknown data in reassembly (this is only PIA buffer right now)."}], "file": "stats.log", "pattern": {"pattern": "%{NUMBER:ts}\\t%{GREEDYDATA:peer}\\t%{INT:mem}\\t%{INT:pkts_proc}\\t%{INT:bytes_recv}\\t%{INT:pkts_dropped}\\t%{INT:pkts_link}\\t%{GREEDYDATA:pkt_lag}\\t%{INT:events_proc}\\t%{INT:events_queued}\\t%{INT:active_tcp_conns}\\t%{INT:active_udp_conns}\\t%{INT:active_icmp_conns}\\t%{INT:tcp_conns}\\t%{INT:udp_conns}\\t%{INT:icmp_conns}\\t%{INT:timers}\\t%{INT:active_timers}\\t%{INT:files}\\t%{INT:active_files}\\t%{INT:dns_requests}\\t%{INT:active_dns_requests}\\t%{INT:reassem_tcp_size}\\t%{INT:reassem_file_size}\\t%{INT:reassem_frag_size}\\t%{INT:reassem_unknown_size}", "name": "BRO_STATS"}, "log_type": "stats"}, {"fields": [], "log_type": "stderr", "file": "stderr.log", "description": "Captures standard error when Bro is\nstarted from BroControl"}, {"fields": [], "log_type": "stdout", "file": "stdout.log", "description": "Captures standard output when Bro is\nstarted from BroControl"}]}